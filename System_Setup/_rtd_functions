#!/bin/bash
#
#::				R T D   F u n c t i o n   L i b r a r y  
#::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
#::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
#::	Author(s):   	SLS, KLS, NB.  Buffalo Center, IA & Avarua, Cook Islands
#:: 	Version:	1.02
#::
#::
#::	Purpose:	To collect and enable the use of code snipplets in other scripts. 
#::			To document these thuroughly so that they may be usefull for learning BASH. 
#::     Usage: 		call this file using the "source" statment in bash.
#:: 
#::     This script is shared in the hopes that
#::     someone will find it usefull.
#::
#::
#::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
#::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
#	
#	Functions defined in this library:
#
#	Function Name: 				Description:
#	----------------------------------------------------------------------------------------------------------------
#	check_dependencies			: Checks that software requirements are met so scripts do not fail 
#	debug_list_loaded_functions		: Lists all loaded RTD functions in the environment
#	dl					: Downloads and installs a package from the internet (a bit insecure)
#	enable_firewall				: Will turn on UFW and add the Allow SSH rule
#	ensure_admin				: Elevates priveledges to admin "root" for the whole script (asks for password)  
#	InstallSoftwareFromRepo			: Installs a package from a repository (supports SUSE, Fedora, Cent OS, Ubuntu Deian etc.)
#	is_software_package_available		: Checks to see if a software package is availabel in a repository (RPM and DEB)
#	is_software_package_installed		: Checks to see if a software package allready is installed
#	notice_rtd_loaded			: Notifies a script that RTD functions are loaded
#	set_colors				: Set colors for prompting on screen in human usable variables: $RED, $GEEN etc.
#	set_install_command			: Determines what install command should be used to install packages from repositories
#	SofwareManagmentAvailabilityCHK		: Checks to see that the software managment system is not busy
#	system_update				: Newer more universal software update function
#	up2date					: Older universal software update function
#	rtd_setup_choices_term_fallback		: For server setup, displays a menu where you may chose CLI productivity software (vim, alpine, byobu etc.).
#	
#	
#	

###########################################################################
##                                                                       ##
##                         Settings                                      ##
##                                                                       ##
###########################################################################

source /opt/rtd/scripts/_rtd_recipies
source /opt/rtd/scripts/_branding



###########################################################################
##                                                                       ##
##                         Functions                                     ##
##                                                                       ##
###########################################################################
#



# Set colors for prompting on screen in human readable variables. These will be set globally
# and can be can be used by in echo statements to modify the color of the message. 
# Examples:  $YELLOW, $RED, $ENDCOLOR (reset), $GREEN, $BLUE
set_colors () {
	YELLOW="\033[1;33m"
	RED="\033[0;31m"
	ENDCOLOR="\033[0m"
	GREEN="\033[0;32m"
	BLUE="\033[0;34m"
	dark0_hard="#1D2021"
        dark0="#282828"
        dark0_soft="#32302F"
        dark1="#3c3836"
        dark2="#504945"
        dark3="#665c54"
        dark4="#7C6F64"
        gray_245="#928374"
        gray_244="#928374"
        light0_hard="#FB4934"
        light0="#FBF1C7"
        light0_soft="#F2E5BC"
        light1="#EBDBB2"
        light2="#D5C4A1"
        light3="#BDAE93"
        light4="#A89984"
        bright_red="#FB4934"
        bright_green="#B8BB26"
        bright_yellow="#FABD2F"
        bright_blue="#83A598"
        bright_purple="#D3869B"
        bright_aqua="#8EC07C"
        bright_orange="#FE8019"
        neutral_red="#CC241D"
        neutral_green="#98971A"
        neutral_yellow="#D79921"
        neutral_blue="#458588"
        neutral_purple="#B16286"
        neutral_aqua="#689D6A"
        neutral_orange="#D65D0E"
        faded_red="#9D0006"
        faded_green="#79740E"
        faded_yellow="#B57614"
        faded_blue="#076678"
        faded_purple="#8F3F71"
        faded_aqua="#427B58"
        faded_orange="#AF3A03"
}





# Function to ensure administrative privileges such that system wide settings 
# or configuration may be done. This function will make the script call itself 
# with sudo if the user ID is not 0 e.g. root.
ensure_admin () {
	[ "$UID" -eq 0 ] || echo -e $YELLOW "This script needs administrative access..." $ENDCOLOR
	[ "$UID" -eq 0 ] || exec sudo bash "$0" "$@"
}





# add global install command for portability and convenience
# If you need to use this script in an rpm based system you could modify the install
# command here to suit dnf, yum, zypper... By default packages of patternd that do not
# match should be skipped. Use "export option" so child processes also see the variiables.
set_install_command () {

        if [[ "$OSTYPE" == "linux-gnu" ]]; then
	        if hash pkcon 2>/dev/null; then
			# If package kit is available then prefer this
			echo -e $YELLOW "Setting install options for Package Kit" $ENDCOLOR	 
			export _INSTCMD="pkcon -y  install"
		elif hash yum 2>/dev/null; then
			# If package kit is not available try yum (RedHat, Cent OS, Fedora)
	        	echo -e $YELLOW "Setting install options for YUM" $ENDCOLOR
	        	export _INSTCMD="yum -y  install"
	        elif hash apt 2>/dev/null; then
			# If package kit is not available try apt (Debian, Ubuntu, and all derivatives)
		        echo -e $YELLOW "Setting install options for DEB" $ENDCOLOR	        
	                export _INSTCMD="apt-get -y -qq --allow-change-held-packages --ignore-missing install"
	                export DEBIAN_FRONTEND=noninteractive
	        elif hash zypper 2>/dev/null; then
			# If package kit is not available try zypper (Open SUSE)
	                echo -e $YELLOW "Setting install options for ZYPPER" $ENDCOLOR
		        export _INSTCMD="zypper install -y "
		else
		        echo -e $YELLOW "This system does not seem to have a software managment system" $ENDCOLOR
		        exit 1
	        fi

        elif [[ "$OSTYPE" == "freebsd"* ]]; then
                echo "Free BSD is currently unsupported... "
                export _INSTCMD="echo I dont know how to install suff on FreeBSD!"
        else
               echo "I have no Idea what this system is"
                export _INSTCMD="echo Whatever!"
                exit 1
        fi
}







# Function to enable system firewall and add a given rule. This simple function
# enables Uncomplicated Fire Wall (UFW) and adds a rule to allow SSH to 
# pass. 
enable_firewall () {
	if hash ufw 2>/dev/null; then
			echo -e $YELLOW "Configure Firewall:" $ENDCOLOR
			ufw enable && ufw allow ssh
	else
			echo -e $faded_orange "UFW not present on this system: please turn on the firewall and configure it manually!" $ENDCOLOR
	fi
}





# Function to ease and make consistent the downloading of the non repository packages and
# install them. This function presently only works with apt. This should be expanded to include
# RPM packages as well. 
# First parameter is the URL, second is the name of the deb, to bypass version
# naming issues, use wildcards like skype*.deb
dl ()
{
	if [ -z "$_ERRLOGFILE" ]; then $_ERRLOGFILE=$0.log ; else echo "Logfile is set to: '$_ERRLOGFILE'"; fi
	if [ -z "$_LOGFILE" ]; then $_LOGFILE=$0.log ; else echo "Logfile is set to: '$_LOGFILE'"; fi
	check_dependencies wget
	echo  "   - geting package $2 ..."
	wget -P /var/apt/cache/archives/ $1 1>>$_LOGFILE 2>>$_ERRLOGFILE
	echo "    - Installing package $2 ..."
	check_dependencies pkcon
	pkcon install-local -y /var/apt/cache/archives/$2 1>>$_LOGFILE 2>>$_ERRLOGFILE

}





# Function to check and see if the system software managment is available. In some cases 
# the sofware managment system may be in use. Should this be the case, this function will
# wait undill the system is free for use. 
# TODO: Add support for fedora, Centos, SuSE.
SofwareManagmentAvailabilityCHK ()
{
	echo ""
        echo -e $YELLOW"--- Checking if software maintenance system is available:" $ENDCOLOR
        i=0
        tput sc
        while fuser /var/lib/dpkg/lock >/dev/null 2>&1 ; do
            case $(($i % 4)) in
                0 ) j="-" ;;
                1 ) j="\\" ;;
                2 ) j="|" ;;
                3 ) j="/" ;;
            esac
            tput rc
            echo -en "\r[$j] Waiting for other software managers to finish..."\


            sleep 5
            ((i=i+1))
        done
}





# Function to simplify updating system completely. At present this function sets the 
# highest preference to use "pkcon", the command line interface of "Package Kit" since
# this is the most consistent across different distrbutions. It may even work on BSD.
# Only if "pkcon" is not available, will the function use the identified distro native 
# software manager: apt, yum, zypper etc. This is to maintain stability since a distro may 
# alias another distributions command (like SuSE does with apt) to be helpfull. 
# This is one of the first update functions written and is kept for compatibility.  
up2date ()
{
	echo -e $YELLOW"--- Running up2date function:" $ENDCOLOR
	if [ -z "$_ERRLOGFILE" ]; then $_ERRLOGFILE=$0.log ; else echo "     Logfile is set to: '$_ERRLOGFILE'"; fi
        if [ -z "$_LOGFILE" ]; then $_LOGFILE=$0.log ; else echo "     Logfile is set to: '$_LOGFILE'"; fi

        if hash pkcon 2>/dev/null; then
		pkcon update -y 1>>$_LOGFILE 2>>$_ERRLOGFILE 
	elif hash yum 2>/dev/null; then
	        yum update -y 1>>$_LOGFILE 2>>$_ERRLOGFILE 
        elif hash apt 2>/dev/null; then
	        apt-get update 1>>$_LOGFILE 2>>$_ERRLOGFILE
	        apt-get dist-upgrade -y -qq --allow-change-held-packages --ignore-missing 1>>$_LOGFILE 2>>$_ERRLOGFILE
	        apt-get autoremove -y 1>>$_LOGFILE 2>>$_ERRLOGFILE 
        elif hash zypper 2>/dev/null; then
                return zypper up 1>>$_LOGFILE 2>>$_ERRLOGFILE 
	else
	        return 3
        fi
}





# Function to check if a piece of software is installed. This function will first check
# if the package manager is deb, zypper or rpm, and then take one parameter passed
# and evauate if a software package by that name is installed. This function
# will return a "0" or "1" return based on the package managers return code.
# Call this function by: 
# is_software_package_installed "package name" 
#                 or 
# is_software_package_installed "$1" if calling this function from a script
# or another function receiving a parameter.
#
is_software_package_installed () 
{
        if hash yum 2>/dev/null; then
	        rpm -q "$1" > /dev/null 2>&1 && return 0 || return 1
        elif hash apt 2>/dev/null; then
	        dpkg -l "$1" 2>/dev/null |tail -1 |grep "ii  $1" > /dev/null 2>&1 && return 0 || return 1
        elif hash zypper 2>/dev/null; then
                zypper se "$1" > /dev/null 2>&1 && return 0 || return 1
	else
	        return 3
        fi
}


	

# Function to chek if a package is available in whetever repository, and 
# if there return a "0" and if not return a "1" or a "3" if there is no recognizable 
# package manager found. the function expects the name of the package 
# to be a parameter passed to this fuction. Call this function by: 
# is_software_package_available "package name" 
#                 or 
# is_software_package_available "$1" if calling this function from a script
# or another function receiving a parameter.
#
# Supported base distributions: Fedora . SuSE . Debian
is_software_package_available () 
{
        if hash yum 2>/dev/null; then
	        yum list available "$1" &> /dev/null && return 0 || return 1
        elif hash apt 2>/dev/null; then
                apt -qq list "$1" 2>/dev/null | grep -q "$1" && return 0 || return 1
        elif hash zypper 2>/dev/null; then
                return zypper info "$1" &> /dev/null && return 0 || return 1
	else
	        return 3
        fi

}




# Function to simplify the installation of software by including all display and 
# installation logic for a given software provider. This should be expanded to include flatpack
# snap for example. It should be the same consistent way no matter flavor of Linux. 
# This function uses the "$_INSTCMD" to install software. "$_INSTCMD" is defined separatley 
# in the "set_install_command" function (a dependency to this function) and could 
# be an RPM or deb string, or even snap or flatpack. A preference order between package system and
# snap or flatpack use. 
InstallSoftwareFromRepo ()
{
	# Check that function dependencies are available. 
	# for _i in set_install_command is_software_package_installed is_software_package_available 
	# do
	# 	if hash $_i 2>/dev/null; then
	# 		return 0
	# 	else
	# 		echo -e $RED "InstallSoftwareFromRepo: I Depend on funcons that are not available!"  $ENDCOLOR
	# 		return 1
	# 		exit
	# 	fi
	# done
	# Ensure that the CLI command is determined for this system. 
	set_install_command >>/dev/null 2>&1

	# make some decent display terminal Graphics...
        PAD="------------------------------------------------"
	LINE=$(printf "%s %s" "$@" "$PAD" | cut -c 1-${#PAD})
	PRE=" - Installing $LINE :"
	# Test if package name is installed, if not then...
        if ! is_software_package_installed "$1"; then
        	if is_software_package_available "$1"; then
			echo -ne "$PRE"\ & $_INSTCMD "$1" >>$0.log 2>&1 && printf "%b%-6s%b [ \xE2\x9C\x94 ] $GREEN OK!$ENDCOLOR \n" ||printf "%b%-6s%b [ ! ] $RED FAILED $ENDCOLOR \n"
			if [ $? != 0 ]; 
			then 
				return 1 & exit 1
			fi 
		else
			echo -ne "$PRE"\ && printf "%b%-6s%b [ \xE2\x9C\x94 ] $YELLOW NOT AVAILABLE... $ENDCOLOR \n"
                fi
        else
		echo -ne "$PRE"\ && printf "%b%-6s%b [ \xE2\x9C\x94 ] $YELLOW Allready Installed... $ENDCOLOR \n"
        fi
}




# Function to check that a piece of software is installed and if not install it.
# Works for apt based systems currently. The function will take a parameter that is expected to
# match the softwre command line name or rather the name of the package. This should get
# updated to also check and install from snap and flatpack. 
check_dependencies () {
        #---------------------------------------------------------------
        echo "Checking for script dependencies and install if not there..."
        #---------------------------------------------------------------
            if is_software_package_installed $1 ; then
                echo -e $GREEN"I found that $1 is present on this system... thankyou for that! " $ENDCOLOR
            else
                echo -e $YELLOW"You seem to have no $1... I will try to get it... " $ENDCOLOR
                InstallSoftwareFromRepo $1
                    if [ $? != 0 ];
                    then
                        echo -e $RED "That install didn't work out so well." 
                        echo -e "Please manually try to add the software since I couldn't do it." $ENDCOLOR
                        exit
                    fi
                echo "OK Done! Continuing..."
            fi
}




# Function to update the Linux based system. This function is universal for all 
# distributions that have package kit available. It works in the same manner on
# RedHat/Fedora, Debian/Ubuntu and all their derivatives. When invoked as a 
# part in a script, it is wist to ensure that the package kit is available 
# by using the "check_dependencies" function to ensure that the software is available. 
system_update () {
    if hash pkcon 2>/dev/null; then
    	pkcon refresh
        pkcon update -y
    else
        echo "You seem to have now Package Kit... I will try to get it... "
        echo "I will need to become admin to do that..."
        sudo check_dependencies packagekit
            if [ $? != 0 ];
            then
                echo "That install didn't work out so well."
                echo "Defaulting to the onld Up2Date Function"
                up2date
            fi
        echo "OK trying again!"
    	pkcon refresh
        pkcon update -y
    fi
}



# Function to simply display that the functions have been loaded when this function library has been called.
function notice_rtd_loaded ()
{
        echo -e $GREEN "RuntimeData function support is loaded in this script." $ENDCOLOR
        export RTDFUNCTIONS=1

}


# Function to display legacy installation options. This will install software that is usefull
# on a really old system, or a remote system only accessible via SSH. This may be a good 
# usecase if oyu happen to be in an opressed geographic locaiton where your only option is 
# to ssh to a remote server and access email and web that way. Perfomance in these cases
# may be very poor over the internet (as for example with the great firewall of China). In
# Such a case it would be usefull to have the good old CLI software! :) 
function rtd_setup_choices_term_fallback () {
	# List Options to be available for choice in the RTD System Configurator...
	cmd=(whiptail --backtitle "RTD OEM System Builder Configuraton Menu" --title "Terminal Software Options Menu" --separate-output --checklist "We did not find a graphical interface. No matter, you can be productive in the cli environment. Please Select Software and Configuration below:" 22 85 16 )
	options=(1 "Base RTD OEM Software" on    
		 2 "Alpine email client" on
		 3 "Vim text editor" on
		 4 "Finch multi protocol chat" on
		 5 "Word Grinder word precessor" on
		 6 "Spreadsheet Calculator" on
		 7 "TPP Presentation Program" on
		 8 "Midnight Commander file manager (Norton Commander)" on
		 9 "Cmus Music Player" on
		 10 "Byobu Terminal Window Manger" on
		 11 "W3M web Browser" on
		 12 "LYNX Web Browser" on
		 13 "Mega.nz command line tools (Mega-CMD)" on
		 14 "Rtorrent torrent download software" off
		 15 "Install the OpenVpn client Software" on
		 16 "Games: Freesweep mine sweep game" on
		 17 "Games: Bastet Tetris Game" on
		 18 "OEM Customizatons" on
		)

			choices=$("${cmd[@]}" "${options[@]}" 2>&1 >/dev/tty)
			clear
			for choice in $choices
			do
			    case $choice in
				1)
				for i in wine-stable ffmpeg netstat nmcli htop powertop iftop monit nethogs bmon darkstat ss mtr glances nmap iostat multitail ncdu multitail ; do InstallSoftwareFromRepo $i ; done
				;;
				2)
				InstallSoftwareFromRepo alpine
				;;
				3)
				InstallSoftwareFromRepo vim	
				;;
				4)
				InstallSoftwareFromRepo finch
				;;
				5)
				InstallSoftwareFromRepo	wordgrinder		
				;;
				6)
				InstallSoftwareFromRepo sc
				;;
				7)
				InstallSoftwareFromRepo tpp
				;;
				8)
				InstallSoftwareFromRepo mc
				;;
				9)
				InstallSoftwareFromRepo cmus
				;;
				10)
				InstallSoftwareFromRepo byobu
				;;
				11)
				InstallSoftwareFromRepo w3m
				;;
				12)
				InstallSoftwareFromRepo lynx
				;;
				13)
				dl https://mega.nz/linux/MEGAsync/xUbuntu_19.04/amd64/ megacmd-*.deb
				;;
				14)
				InstallSoftwareFromRepo rtorrent
				;;
				15)
				InstallSoftwareFromRepo openvpn
				;;
				16)
				InstallSoftwareFromRepo freesweep
				;;
				17)
				InstallSoftwareFromRepo bastet
				;;
				18)
				recipie_OEM_config
				;;
			esac
		done
}




# Function to list all functions loaded... for debugging purposes.
function debug_list_loaded_functions ()
{
	echo -e $BLUE "RTD Functions Loaded:"
	declare -F | awk '{print $NF}' | sort | egrep -v "^_" 
}



# make prompt colors avaiable to any script that includes this function lbrary.
set_colors
notice_rtd_loaded 


if [[ "$1" = "--list" ]]; then
	debug_list_loaded_functions
fi



