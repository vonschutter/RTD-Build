#!/bin/bash
RTD_VERSION=2.0
<<Library_Documentation
::				R T D   F u n c t i o n   L i b r a r y
::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
::	Author(s):   	SLS, KLS, NB.  Buffalo Center, IA & Avarua, Cook Islands
:: 	Version:	2.0
::
::
::	Purpose:	To collect and enable the use of code snipplets in other scripts.
::			To document these thuroughly so that they may be usefull for learning BASH.
::	Usage: 		call this file using the "source" statment in bash.
::
::	This script is shared in the hopes that
::	someone will find it usefull.
::
::
::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

	Functions defined in this library:

	Function Name: 					Description:
	----------------------------------------------------------------------------------------------------------------
	add_software_task 				: Wrapper function to execute a command and display pretty terminal OK or FAIL  
	backup_running_vm 				: Backs up all running virtual machines on the local computer 
	change_disk_pass 				: Allows user to change password of the system partition encrypted disk
	check_dependencies 				: Checks that software requirements are met so scripts do not fail 
	check_if_password_p0wned 			: Allows user to check if an intended password is already in well known dictionaries 
	check_menu_availability 			: Checks if it is possible to display graphical menus in a terminal
	cleanup_and_finish 				: Cleans and clears variables and temp files used by the media creations functions
	create_iso_image 				: Creates aan OS iso image 
	create_iso_image_debian 			: Creates a Debian iso image
	debug_list_loaded_functions			: Lists all loaded RTD functions in the environment
	display_result 					: Displays command results in a pretty terminal box 
	dl						: Downloads and installs a package from the internet (a bit insecure)
	download_and_manipulate_iso_debian 		: Download and modify a debian iso to automatically install + OEM addons 
	enable_firewall					: Will turn on UFW and add the Allow SSH rule 
	ensure_admin					: Elevates priveledges to admin "root" for the whole script (asks for password)
	err_no_menu_system_found 			: Function to handle what to do if it is not possible to currently display menus in a terminal 
	generate_report_disk_space_used_by_directory 	: Generate a disk usage report 
	InstallSoftwareFromRepo				: Installs a package from a repository (supports SUSE, Fedora, Cent OS, Ubuntu Deian etc.) 
	is_software_package_available			: Checks to see if a software package is availabel in a repository (RPM and DEB)
	is_software_package_installed			: Checks to see if a software package allready is installed
	make_kvm_virtual_machine_now_from_debian_org 	: #20 
	make_kvm_virtual_machine_now_from_iso 		: #21 
	make_kvm_virtual_machine_now_from_ubuntu_com 	: #22 
	make_preseed_cfg 				: #23 
	notice_rtd_loaded				: Notifies a script that RTD functions are loaded
	oem_PowerShell_compatability 			: #24 
	prepare_environment_for_iso_creation 		: #25 
	rtd_oem_cfg_Account_Setup 			: #26 
	rtd_oem_cfg_post_task_sequence_default	 	: #27 
	rtd_oem_check_inet_access 			: #28 
	rtd_oem_find_live_release 			: #29 
	rtd_oem_kde_set_wallpaper 			: #30 
	rtd_oem_pause 					: #31 
	rtd_oem_preseed_cfg_Addon_MinecraftServer 	: #32 
	rtd_oem_preseed_cfg_Addon_Tasks 		: #33 
	rtd_oem_preseed_cfg_Disk_Layout 		: #34 
	rtd_oem_preseed_cfg_EFI 			: #35 
	rtd_oem_preseed_cfg_GRUB_Bootloader_Installation: #36 
	rtd_oem_preseed_cfg_Localization 		: #37 
	rtd_oem_preseed_cfg_Network_Configuration 	: #38 
	rtd_oem_preseed_cfg_Package_Selection 		: #39 
	rtd_oem_preseed_cfg_Prevent_Install_On_USB 	: #40 
	rtd_oem_preseed_cfg_Unattended_Install 		: #41 
	rtd_oem_preseed_ubuntu_cfg_KS_CFG_Options 	: #42 
	rtd_oem_release_upgrade 			: #43 
	rtd_oem_remove_non_western_latin_fonts 		: #44 
	rtd_oem_remove_software 			: #45 
	rtd_oem_reseal 					: #46 
	rtd_oem_reset_default_environment_config 	: #47 
	rtd_oem_setup_brand_splash_screen 		: #48 
	rtd_oem_ubuntu_auto_install_iso_builder 	: #49 
	rtd_ppa_checker 				: #50 
	rtd_setup_choices_preseed 			: #51 
	rtd_setup_choices_term_fallback			: For server setup, displays a menu where you may chose CLI productivity software (vim, alpine, byobu etc.).
	rtd_update_system 				: #53 
	rtd_wait_for_internet_availability 		: #54 
	run_command_in_gnome_user_session 		: #55 
	set_colors					: Set colors for prompting on screen in human usable variables: $RED, $GEEN etc.
	set_install_command				: Determines what install command should be used to install packages from repositories
	SofwareManagmentAvailabilityCHK			: Checks to see that the software managment system is not busy
	system_update					: Newer more universal software update function
	up2date						: Older universal software update function

Use Google Coding standards:
In general any function that is not both obvious and short must be commented. Any function in a library must be commented regardless of 
length or complexity. It should be possible for someone else to learn how to use your program or to use a function in your library 
by reading the comments (and self-help, if provided) without reading the code.

All function comments should describe the intended API behaviour using:

1	Description of the function.
2	Globals: List of global variables used and modified.
3	Arguments: Arguments taken.
4	Outputs: Output to STDOUT or STDERR.
5	Returns: Returned values other than the default exit status of the last command run.

Library_Documentation









#              .--.           .---.        .-.
#          .---|--|   .-.     | A |  .---. |~|    .--.
#       .--|===|Ch|---|_|--.__| S |--|:::| |~|-==-|==|---.
#       |%%|NT2|oc|===| |~~|%%| C |--|   |_|~|CATS|  |___|-.
#       |  |   |ah|===| |==|  | I |  |:::|=| |    |GB|---|=|
#       |  |   |ol|   |_|__|  | I |__|   | | |    |  |___| |
#       |~~|===|--|===|~|~~|%%|~~~|--|:::|=|~|----|==|---|=|
#       ^--^---'--^---^-^--^--^---'--^---^-^-^-==-^--^---^-'
###########################################################################
##                                                                       ##
##                        Library Settings                               ##
##                                                                       ##
###########################################################################









source /opt/rtd/scripts/_rtd_recipies
source /opt/rtd/scripts/_branding

# Base folder structure for optional administrative commandlets and scripts:
_RTDSCR=$(if [ -f /opt/rtd/scripts ]; then echo /opt/rtd/scripts ; else ( mkdir -p /opt/rtd/scripts & echo  /opt/rtd/scripts ) ; fi )
_RTDCACHE=$(if [ -f /opt/rtd/cache ]; then echo /opt/rtd/cache ; else ( mkdir -p /opt/rtd/cache & echo  /opt/rtd/cache ) ; fi )
_RTDLOGSD=$(if [ -f /var/log/rtd ]; then echo /var/log/rtd ; else ( mkdir -p /var/log/rtd & echo  /var/log/rtd ) ; fi )

# Determine log file directory
_ERRLOGFILE=$_RTDLOGSD/$( basename $0)-error.log
_LOGFILE=$_RTDLOGSD/$( basename $0).log
_STATUSLOG=$_RTDLOGSD/$( basename $0)-status.log













#     |>>>                                                      |>>>
#     |                     |>>>          |>>>                  |
#     *                     |             |                     *
#    / \                    *             *                    / \
#   /___\                 _/ \           / \_                 /___\
#   [   ]                |/   \_________/   \|                [   ]
#   [ I ]                /     \       /     \                [ I ]
#   [   ]_ _ _          /       \     /       \          _ _ _[   ]
#   [   ] U U |        {#########}   {#########}        | U U [   ]
#   [   ]====/          \=======/     \=======/          \====[   ]
#   [   ]    |           |   I |_ _ _ _| I   |           |    [   ]
#   [___]    |_ _ _ _ _ _|     | U U U |     |_ _ _ _ _ _|    [___]
#   \===/  I | U U U U U |     |=======|     | U U U U U | I  \===/
#    \=/     |===========| I   | + W + |   I |===========|     \=/
#     |  I   |           |     |_______|     |           |   I  |
#     |      |           |     |||||||||     |           |      |
#     |      |           |   I ||vvvvv|| I   |           |      |
# _-_-|______|-----------|_____||     ||_____|-----------|______|-_-_
#    /________\         /______||     ||______\         /________\
#   |__________|-------|________\_____/________|-------|__________|

###########################################################################
##                                                                       ##
##                       Library Functions                               ##
##                                                                       ##
###########################################################################











set_colors ()
{
# Set colors for prompting on screen in human readable variables. These will be set globally
# and can be can be used by in echo statements to modify the color of the message.
# Examples:  $YELLOW, $RED, $ENDCOLOR (reset), $GREEN, $BLUE
# Usage: 
#	Simply call this function by stating its name:
# 	set_colors
# 	
# "ðŸ”´  ðŸ”µ "
# The function will not return any sucess or failure codes. It will do its best and exit.
# End of documentation

# Foreground & background colour commands

# tput setab [1-7] # Set the background colour using ANSI escape
# tput setaf [1-7] # Set the foreground colour using ANSI escape


# Black        0;30     Dark Gray     1;30
# Red          0;31     Light Red     1;31
# Green        0;32     Light Green   1;32
# Brown/Orange 0;33     Yellow        1;33
# Blue         0;34     Light Blue    1;34
# Purple       0;35     Light Purple  1;35
# Cyan         0;36     Light Cyan    1;36
# Light Gray   0;37     White         1;37

#      Num  Colour    #define         R G B
# 0    black     COLOR_BLACK     0,0,0
# 1    red       COLOR_RED       1,0,0
# 2    green     COLOR_GREEN     0,1,0
# 3    yellow    COLOR_YELLOW    1,1,0
# 4    blue      COLOR_BLUE      0,0,1
# 5    magenta   COLOR_MAGENTA   1,0,1
# 6    cyan      COLOR_CYAN      0,1,1
# 7    white     COLOR_WHITE     1,1,1

# Text mode commands

# tput bold    # Select bold mode
# tput dim     # Select dim (half-bright) mode
# tput smul    # Enable underline mode
# tput rmul    # Disable underline mode
# tput rev     # Turn on reverse video mode
# tput smso    # Enter standout (bold) mode
# tput rmso    # Exit standout mode

# Cursor movement commands

# tput cup Y X # Move cursor to screen postion X,Y (top left is 0,0)
# tput cuf N   # Move N characters forward (right)
# tput cub N   # Move N characters back (left)
# tput cuu N   # Move N lines up
# tput ll      # Move to last line, first column (if no cup)
# tput sc      # Save the cursor position
# tput rc      # Restore the cursor position
# tput lines   # Output the number of lines of the terminal
# tput cols    # Output the number of columns of the terminal

# Clear and insert commands

# tput ech N   # Erase N characters
# tput clear   # Clear screen and move the cursor to 0,0
# tput el 1    # Clear to beginning of line
# tput el      # Clear to end of line
# tput ed      # Clear to end of screen
# tput ich N   # Insert N characters (moves rest of line forward!)
# tput il N    # Insert N lines

# Other commands

# tput sgr0    # Reset text format to the terminal's default
# tput bel     # Play a bell




  	local ecode="\033["

	yellow="${ecode}1;33m"
	darkyellow="${ecode}0;33m"
	red="${ecode}1;31m"
	darkred="${ecode}0;31m"
	endcolor="${ecode}0m"
	green="${ecode}1;32m"
	darkgreen="${ecode}1;32m"
	blue="${ecode}1;34m"
	darkblue="${ecode}0;34m"
	cyan="${ecode}1;36"
	darkcyan="${ecode}0;36"
	gray="${ecode}0;37"
	purple="${ecode}1;35"
	darkpurple="${ecode}0;35"

	# Back compatability w. old scripts
	YELLOW="$yellow"
	RED="$red"
	ENDCOLOR="$endcolor"
	GREEN="$green"
	BLUE="$blue"

	music="
	â•”â•â•â•— â™« \n
	â•‘â–ˆâ–ˆâ•‘ â™ªâ™ª \n
	â•‘â–ˆâ–ˆâ•‘â™«â™ª \n
	â•‘ â—Žâ™«â™ªâ™« \n
	â•šâ•â•â• Turn Up The Music!!! \n
	"

	picachu="
	â¢€â£ â£¾â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â €â €â €â €â£ â£¤â£¶â£¶ \n
	â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â €â €â €â¢°â£¿â£¿â£¿â£¿ \n
	â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£§â£€â£€â£¾â£¿â£¿â£¿â£¿ \n
	â£¿â£¿â£¿â£¿â£¿â¡â ‰â ›â¢¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â¡¿â£¿ \n
	â£¿â£¿â£¿â£¿â£¿â£¿â €â €â €â ˆâ ›â¢¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â ¿â ›â ‰â â €â£¿ \n
	â£¿â£¿â£¿â£¿â£¿â£¿â£§â¡€â €â €â €â €â ™â ¿â ¿â ¿â »â ¿â ¿â Ÿâ ¿â ›â ‰â €â €â €â €â €â£¸â£¿ \n
	â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£·â£„â €â¡€â €â €â €â €â €â €â €â €â €â €â €â €â €â €â €â¢€â£´â£¿â£¿ \n
	â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â â €â €â €â €â €â €â €â €â €â €â €â €â €â €â  â£´â£¿â£¿â£¿â£¿ \n
	â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â¡Ÿâ €â €â¢°â£¹â¡†â €â €â €â €â €â €â£­â£·â €â €â €â ¸â£¿â£¿â£¿â£¿ \n
	â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â ƒâ €â €â ˆâ ‰â €â €â ¤â „â €â €â €â ‰â â €â €â €â €â¢¿â£¿â£¿â£¿ \n
	â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â¢¾â£¿â£·â €â €â €â €â¡ â ¤â¢„â €â €â €â  â£¿â£¿â£·â €â¢¸â£¿â£¿â£¿ \n
	â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â¡€â ‰â €â €â €â €â €â¢„â €â¢€â €â €â €â €â ‰â ‰â â €â €â£¿â£¿â£¿ \n
	â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£§â €â €â €â €â €â €â €â ˆâ €â €â €â €â €â €â €â €â €â €â¢¹â£¿â£¿ \n
	â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â£¿â ƒâ €â €â €â €â €â €â €â €â €â €â €â €â €â €â €â €â €â¢¸â£¿â£¿ \n
	"
	chess="â™Ÿï¸ â™” â™• â™– â™— â™˜ â™™ â™š â™› â™œ â™ â™ž â™Ÿ"
	colorcircle="ðŸ”´ ðŸŸ  ðŸŸ¡ ðŸŸ¢ ðŸ”µ ðŸŸ£ ðŸŸ¤"
	colorsquares=" ðŸŸ¥ ðŸŸ§ ðŸŸ¨ ðŸŸ© ðŸŸ¦ ðŸŸª ðŸŸ«"
}





change_disk_pass ()
{
# Function to change the passphrase fo an encrypted storage device.
# It will offer to change the first encrypted volume found by blockid.
# It is unclear how this will work if there are multiple encrypted volumes found.
# The function does not expect an argument. It will prompt for a password. 
# Usage: 
# change_disk_pass
#
#
# End of Documentation

	clear
	echo -e "$RED""Changing the disk encryption password for your hard drive:""$ENDCOLOR"
	cryptsetup luksChangeKey "$(blkid | grep crypto_LUKS|  cut -d : -f 1)"
	read -p "Press  [ ENTER ] to continue:"

}





display_result ()
{
# Function to read a variable "result" and display its contents. The purpose of this function
# is simply to make it easy and convenient to display a mesage to an end user in a terminal 
# in a nice way. To use this function simply call it after populating the variable result.
# Example: 
#
# result=$( command with output)
# display result "title of the mesage" 
#
# End of Documentation

	$RTD_GUI --backtitle "$BRANDING" --title "$1" --msgbox "$result" $HEIGHT $WIDTH 
}




rtd_oem_release_upgrade ()
{
# Function to attempt to perform a release upgade on several Linux distributions. 
# Supported distributions are: Ubuntu, Pop! OS, Debian, SUSE, and fedora.
# This function does not require any arguments but will respect "interactive". The "interactive"
# parameter will force the function to pause if a supported distribution is not found.
# It will check for a supported distribution and attempt the upgrade if possible. 
# If a supported distribution is not detected the function will do nothing.
# 
# Usage (in a script):
#  rtd_oem_release_upgrade [ string ]
#
# [ string ] : interactive
#
# End of Documentation



	local set interactive=$1
	unset result
	TMP_DISC_DIR=$(mktemp -d )
		if hostnamectl |grep "Ubuntu" 2>/dev/null ; then
			echo -e $YELLOW"this may take some time, please be patient!" $ENDCOLOR
			apt clean && apt update -m ; dpkg --configure -a ; apt install -f ; apt dist-upgrade ; apt autoremove --purge
			do-release-upgrade 1> >(tee "$TMP_DISC_DIR"/stdout ) 2> >(tee "$TMP_DISC_DIR"/stderr >&2 )
			result="$( cat "$TMP_DISC_DIR"/stdout; cat "$TMP_DISC_DIR"/stderr)"
			display_result "Release Upgrade Attempt Result: "
			rm -r "$TMP_DISC_DIR" ; unset TMP_DISC_DIR
		elif hostnamectl |grep "Pop!_OS" 2>/dev/null ; then
			echo -e $YELLOW"this may take some time, please be patient!" $ENDCOLOR
			apt clean && apt update -m ; dpkg --configure -a ; apt install -f ; apt dist-upgrade ; apt autoremove --purge
			do-release-upgrade 1> >(tee "$TMP_DISC_DIR"/stdout ) 2> >(tee "$TMP_DISC_DIR"/stderr >&2 )
			result="$( cat "$TMP_DISC_DIR"/stdout; cat "$TMP_DISC_DIR"/stderr)"
			display_result "Release Upgrade Attempt Result: "
			rm -r "$TMP_DISC_DIR" ; unset TMP_DISC_DIR
		elif hostnamectl |grep "Debian" 2>/dev/null ; then
			echo -p $RED"Debian does not provide a upgrade tool..." $ENDCOLOR
			result="Debian does not have an in place upgrade tool. Please edit the /etc/apt/sources.list and use the disd-upgrade option"
			display_result "Release Upgrade Attempt Result: "
		elif hostnamectl |grep "SUSE" 2>/dev/null ; then
			echo -e $YELLOW"this may take some time, please be patient!" $ENDCOLOR
			zypper dup 
		elif hostnamectl |grep "fedora" 2>/dev/null ; then
			releasever=$($RTD_GUI --title "Fedora Upgrade Confirmation" --inputbox "Please enter the Fedora version you want to upgrade to. Please make sure that it has been published. You are currently using: $(hosnamectl)  only numbers are valid" 8 78  3>&1 1>&2 2>&3)
			sudo dnf upgrade --refresh
			sudo dnf install dnf-plugin-system-upgrade
			sudo dnf system-upgrade download --refresh --releasever="$releasever"
			sudo dnf system-upgrade
		else
			[[ "$interactive" == "interactive" ]] && read -p "This option requires the program (do-release-upgrade) (Ubuntu) or OpenSUSE (zypper) on your system. Press [Enter] key to return to menu."
		fi
		return 
}






rtd_oem_setup_brand_splash_screen()
{
# Function to brand the installer splash screen for the customized installer
# downloaded from a ginve vendor. This function expects a few simple peices of information:
# parameter 1: full path to image file to be branded.
# parameter 2: quoted text to be incerted.
#   
# Usage: 
# rtd_oem_setup_brand_splash_screen [string] [string]
# 
# [string]: /path/to/imagefile.png, "test to brand image with"
#
# rtd_oem_setup_brand_splash_screen /tmp/splash.png "Hi! I am a lable!"
#
# End of Documentation

	image_file_to_brand=$1
	text_to_brand_with=$2

	# Ensure that imagemagik is installed so images can be manipulated.
	check_dependencies imagemagick

	# Default locations and splash screens based on debian and ubuntu, meaning this function will assume you are
	# making an ubuntu or debian boot iso as this is generally what this function was written to do. However these values
	# can be overridden by passing the 2 parameters to this script.
	: "${image_file_to_brand:="$(
		if [ -f $TMP_DISC_DIR/splash.png ]; then
			echo "$TMP_DISC_DIR/splash.png"
		elif  [ -f $TMP_DISC_DIR/isolinux/splash.png ]; then
			echo "$TMP_DISC_DIR/isolinux/splash.png"
		elif [ -f $TMP_DISC_DIR/isolinux/splash.png ]; then
			echo "$TMP_DISC_DIR/isolinux/splash.png"
		fi )" }"

	: "${text_to_brand_with:="$( echo " RunTime Data OEM Install: $PREFERENCE" )" }"

	echo -e $GREEN "found: $image_file_to_brand"  $ENDCOLOR
	echo -e $GREEN "branding with: $text_to_brand_with " $ENDCOLOR

	if [ -f $image_file_to_brand ]; then
		convert $image_file_to_brand -gravity north -stroke '#000C' -strokewidth 3 -annotate 0 "$text_to_brand_with" -stroke none -strokewidth 3 -fill white -annotate 0 " $text_to_brand_with "  edit-out.png
		rm $image_file_to_brand
		mv edit-out.png $image_file_to_brand || echo -e $RED "Image [ $image_file_to_brand ] NOT branded!  " $ENDCOLOR

	fi
}





prepare_environment_for_iso_creation ()
{
# Function to check that all dependencies are available for manipulating the
# net install ISO from Ubuntu. Subsequently, the temporary file locations
# are setup and templates are downloaded.
# 
#
# End of Documentation


	#Include the path to where the isofile will be put...
	: "${TARGET_ISO="$PUT_ISO_FILE_HERE_WHEN_DONE/$TARGET_ISO_FILE_NAME"}"
	# Ensure that all needed software, outside of the most rudimantary,
	# is available to us... If not, the script should exit.
	: "${_DEPENDENCIES="dos2unix cpio gzip genisoimage whois pwgen wget fakeroot xorriso"}"
	#set -e
	for i in $_DEPENDENCIES
	do
		check_dependencies $i
	done

	# Find full paths for the binaries needed since if they are recently
	# added, they may not be found in the current $PATH. These statements will be evaluated
	# when the variables are referenced not here because of the ":". FYI...
	: "${BIN_7Z:=$(type -P 7z)}"
	: "${BIN_XORRISO:=$(type -P xorriso)}"
	: "${BIN_CPIO:=$(type -P gnucpio || type -P cpio)}"
	: "${BIN_QEMU_IMG:=$(type -P qemu-img)}"
	: "${BIN_KVM:=$(type -P kvm)}"
	: "${BIN_QEMU_SYSTEM_X86_64:=$(type -P qemu-system-x86_64 )}"
	: "${ISOHDPFX_BIN:=$(locate isohdpfx.bin  | head -n 1)}"
	: "${PUT_ISO_FILE_HERE_WHEN_DONE:="/home/$SUDO_USER/Virtual-DVDs"}"
	: "${PUT_QCOW_FILE_HERE_WHEN_DONE:="/home/$SUDO_USER/Virtual-HDs"}"
	: "${VOLUME_TITLE:="RTD Auto Installer"}"
	: "${SSH_PUBLIC_KEY_FILE:="/home/$SUDO_USER/.ssh/id_rsa.pub"}"
	: "${PERMANENT_DOWNLOAD_DIR:="/home/$SUDO_USER/Virtual-DVDs/Downloaded"}"

	# Find the location of the public key on this machine...
	# This should be updated to create a key if not there...
	if [ ! -f "$SSH_PUBLIC_KEY_FILE" ];
	then
		echo "Error: public SSH key $SSH_PUBLIC_KEY_FILE not found!"
		echo "You will need to setup automatic login using ssh manually each time you build a server with this media."
		read -p "Press [Enter] to continue..."
	fi

	# Setup the required folder structure...
	CURRENT_DIR="$(pwd)"
	SCRIPT_DIR="$( cd "$( dirname "${BASH_SOURCE[0]}" )" && pwd )"
	TMP_DOWNLOAD_DIR=$(mktemp -d )
	TMP_DISC_DIR=$(mktemp -d )
	TMP_INITRD_DIR=$(mktemp -d )

	for i in $PUT_QCOW_FILE_HERE_WHEN_DONE\
		$PUT_ISO_FILE_HERE_WHEN_DONE\
		$PERMANENT_DOWNLOAD_DIR
	do
		mkdir -p "$i" && chown "$SUDO_USER":"$SUDO_USER" "$i"
	done
}








rtd_oem_ubuntu_auto_install_iso_builder()
{
# Function to generate an edited ISO file from a folder.
# this function expects a minimum of one parameter: ssh-server, ubuntu-desktop, kubuntu-desktop, xubuntu-desktop, lubuntu-desktop etc.
# By default the server ISO image will be downloaded and manipulated. Optionally this function can be told to use the
# Ubuntu Desktop ISO instead of the server iso by passing a second parameter:
# :: function name				:: target		:: iso version to download
# rtd_oem_ubuntu_auto_install_iso_builder 	ubuntu-desktop       	desktop â­ creates auoinstall iso using the Ubuntu live dvd
# rtd_oem_ubuntu_auto_install_iso_builder 	ubuntu-desktop       	live	â­ creates auoinstall iso using the Ubuntu live dvd
# rtd_oem_ubuntu_auto_install_iso_builder 	ubuntu-desktop       	server	â­ creates auoinstall iso using the Ubuntu server dvd
#
# End of Documentation


	CONFIG=$1
	ISO_VER=$2
	prepare_environment_for_iso_creation

	# Retreive list of available Ubuntu versions:
	all=($(wget -O- releases.ubuntu.com -q | perl -ne '/Ubuntu (\d+.\d+.\d+)/ && print "$1\n"' | sort -Vu))

	# Ask for desired version to use:
	UBUNTU_VER=$($RTD_GUI --title "Select Release Version of Ubuntu" --inputbox "Please pick an available ubuntu version by entering it below. Versions to choose from: ${all[*]} If you are not sure just let me choose for you... "  24 110 "${all[-1]}" 3>&1 1>&2 2>&3) ;clear 
	[ "$UBUNTU_VER" ] || UBUNTU_VER=${all[-1]}

	# Find the precice location of the requested ISO image:
	ISO_URL=$(rtd_oem_find_live_release $UBUNTU_VER ubuntu $ISO_VER)
		echo "requested iso for download : $ISO_URL"
		ISO_FILENAME=$(basename $ISO_URL)
		BASE=$(basename $ISO_URL .iso)

	echo "Checking if $ISO_FILENAME already downloaded..."
	iso=$(find "$PERMANENT_DOWNLOAD_DIR" -name "$ISO_FILENAME")
	if [ ! -e "$iso" ]; then
		echo "$ISO_FILENAME is not in cache, downloading..."
		wget -nc $ISO_URL -P "$PERMANENT_DOWNLOAD_DIR" || read -p "Failure to download ISO file"
		iso="$PERMANENT_DOWNLOAD_DIR/$ISO_FILENAME"
	fi

	mnt="${TMP_DISC_DIR:=$(mktemp -d )}"
	TMP_DISC_DIR=$mnt
	write_status "Mounting intallation media..."
	mount $iso $mnt -o user,ro || rtd_oem_pause 1
	write_status "Verifying media presence..."
	cat $mnt/.disk/*info || rtd_oem_pause 1
	auto="$BRANDING_ORG-$CONFIG-auto-install-from-${BASE}"
	write_information "Creating Installations media: $YELOW $auto "
	if [ ! -e $auto ]; then
		cp -a $mnt $auto
		chmod -R +w $auto
	fi
	write_status "Modifying startup instructions...  "
	rtd_oem_setup_brand_splash_screen $mnt/isolinux/splash.png || rtd_oem_pause 1
	write_status "Unmounting $mnt... "
	umount $mnt || rtd_oem_pause 1


	case "$2" in
		desktop | Desktop | live | Live)
			#configure_auto_unattended_ubuntu_live_boot_media $auto $CONFIG && echo -e "$GREEN OK! $ENDCOLOR" || rtd_oem_pause 1
			write_status "Modifying installation instructions in live media... "
			cat > $auto/isolinux/txt.cfg <<- EOF
				default live-install
				label live-install
				menu label ^^Auto Install Ubuntu $CONFIG
				kernel /casper/vmlinuz
				append  file=/cdrom/preseed.cfg auto=true priority=critical debian-installer/locale=en_US keyboard-configuration/layoutcode=us console-setup/ask_detect=false ubiquity/reboot=true languagechooser/language-name=English countrychooser/shortlist=US localechooser/supported-locales=en_US.UTF-8 boot=casper automatic-ubiquity initrd=/casper/initrd quiet splash noprompt noshell ---
			EOF

			make_preseed_cfg $auto $CONFIG

		;;
		*)
			#configure_auto_unattended_ubuntu_server_boot_media $auto $CONFIG && echo -e "$GREEN OK! $ENDCOLOR" || rtd_oem_pause 1
			write_status "Modifying installation instructions in server image... "
			cat > $auto/isolinux/isolinux.cfg <<- EOF
				default install
				label install
				gfxmode=791
				ui gfxboot bootlogo
				path
				timeout 100
				menu label ^Auto Install Ubuntu $CONFIG
				kernel /install/vmlinuz
				append file=/cdrom/preseed/ubuntu-server.seed initrd=/install/initrd.gz ks=cdrom:/ks.cfg preseed/file=/cdrom/preseed.cfg --
			EOF

			touch $auto/preseed.cfg
			cat > $auto/boot/grub/grub.cfg <<- 'EOF'
			set timeout=10
			GRUB_GFXMODE="1024x768"
			set menu_color_normal=white/black
			set menu_color_highlight=black/light-gray
			EOF

			make_preseed_cfg $auto $CONFIG

		;;
	esac


	TARGET_ISO="$PUT_ISO_FILE_HERE_WHEN_DONE/$auto.iso"


	if [[ -f $TARGET_ISO ]]; then
		rm $TARGET_ISO
	fi

	$BIN_XORRISO -as mkisofs -isohybrid-mbr "$ISOHDPFX_BIN" \
		-c isolinux/boot.cat -b isolinux/isolinux.bin \
		-no-emul-boot -boot-load-size 4 -boot-info-table \
		-eltorito-alt-boot -e boot/grub/efi.img -no-emul-boot \
		-isohybrid-gpt-basdat -o "$PUT_ISO_FILE_HERE_WHEN_DONE/$auto.iso" $auto
	rtd_oem_pause $?
	umount -l $mnt
	rm -rf $mnt $auto

	if ($RTD_GUI --title "Media ready" --yesno "Created $auto.iso Would you like to test the new image?." 0 0); then
		check_dependencies qemu-kvm
		qemu-img create -f qcow2 "$PUT_QCOW_FILE_HERE_WHEN_DONE/$auto.qcow2" 10G
		qemu-system-x86_64 -smp 2 -enable-kvm -m 4G --cdrom "$TARGET_ISO" "$PUT_QCOW_FILE_HERE_WHEN_DONE/$auto.qcow2"
	else
		echo "User selected No, exit status was $?."
	fi
}







download_and_manipulate_iso_debian ()
{
# ownload_and_manipulate_iso_debian "debian" "openssh-server" "MinecraftTasks"
# This is a simple command sequence to read the preference of distribution to install
# and what release to get... then download the network install file from debian
# and manipulate the iso file to complete the edited instruction in the preseed.cfg...
#
# End of Documentation

	: "${TARGET_ISO_FILE_NAME:="$1-$2-mini-netinstall-auto.iso"}"
	: "${SOURCE_ISO_URL:="https://cdimage.debian.org/debian-cd/current/amd64/iso-cd/$(curl --silent  https://cdimage.debian.org/debian-cd/current/amd64/iso-cd/MD5SUMS | \grep -o "debian-.*netinst*.iso" |grep -v mac |grep -v edu)"}"
	: "${SOURCE_FIRMWARE:="http://cdimage.debian.org/cdimage/unofficial/non-free/firmware/buster/current/firmware.zip"}"
	TARGET_ISO="$PUT_ISO_FILE_HERE_WHEN_DONE/$TARGET_ISO_FILE_NAME"
	PREFERENCE=$2

		echo -e $YELLOW Geting install image...
		echo -e $GREEN Download: $SOURCE_ISO_URL $ENDCOLOR

	wget -4  -q --show-progress "$SOURCE_ISO_URL" -O "$TMP_DOWNLOAD_DIR/netboot.iso" && "$BIN_7Z" x "$TMP_DOWNLOAD_DIR/netboot.iso" "-o$TMP_DISC_DIR" || echo -e $RED "FAILED to download and extract $SOURCE_ISO_URL" $ENDCOLOR
		echo -e $BLUE; ls $TMP_DISC_DIR ; echo -e $ENDCOLOR
		echo -e $YELLOW Geting non-free firmware...
		echo -e $GREEN Download: $SOURCE_FIRMWARE $ENDCOLOR
	wget -4  -q --show-progress "$SOURCE_FIRMWARE" -O "$TMP_DOWNLOAD_DIR/firmware.zip" && ( mkdir "$TMP_DISC_DIR/firmware" & "$BIN_7Z" x "$TMP_DOWNLOAD_DIR/firmware.zip" "-o$TMP_DISC_DIR/firmware" )

	echo -e $BLUE ; ls $TMP_DISC_DIR/firmware ; echo -e $ENDCOLOR

	# Load the installation answers template.
		echo -e $YELLOW Getting intall instructions template... $ENDCOLOR
	make_preseed_cfg "$TMP_INITRD_DIR" "$PREFERENCE"

# ------------------- Patch 1 grub .cfg ------------------------ #

patch "$TMP_DISC_DIR/boot/grub/grub.cfg" <<PATCH
11a12
> set timeout=10
PATCH

sed -i s/"menuentry --hotkey=g 'Graphical install' {"/"menuentry --hotkey=g 'Automatic Graphical install' {"/g "$TMP_DISC_DIR/boot/grub/grub.cfg"
sed -i s/"menuentry --hotkey=g 'install' {"/"menuentry --hotkey=g 'Automatic install' {"/g "$TMP_DISC_DIR/boot/grub/grub.cfg"
sed -i s/"menu label ^Graphical install"/"menu label ^Automatic Graphical install"/g "$TMP_DISC_DIR/isolinux/gtk.cfg"
sed -i s/"menu label ^Install"/"menu label ^Automatic Install"/g "$TMP_DISC_DIR/isolinux/txt.cfg"
# -------------------------------------------------------------- #


# ---------------------Patch 2 isolinux.cfg -------------------- #

dos2unix "$TMP_DISC_DIR/isolinux/isolinux.cfg"
patch "$TMP_DISC_DIR/isolinux/isolinux.cfg" <<PATCH_II
7c7
< timeout 0
---
> timeout 100
PATCH_II

# -------------------------------------------------------------- #

	# Edit the installation instructions file...
	sed -i s/oem-replace-me-desktop-selection/$PREFERENCE/g "$TMP_INITRD_DIR/preseed.cfg"
	mkdir "$TMP_INITRD_DIR/custom" && cp "$SSH_PUBLIC_KEY_FILE" "$TMP_INITRD_DIR/custom/userkey.pub" || echo -e $RED "Failed to create $TMP_INITRD_DIR/custom" $ENDCOLOR

# ---------------------Create ssh key service ------------------ #

cat << SSH_KEY_KEYGEN > "$TMP_INITRD_DIR/custom/ssh-host-keygen.service"
[Unit]
Description=OpenSSH Server Key Generation
Before=ssh.service

[Service]
ExecStart=/usr/bin/ssh-keygen -A
Type=oneshot
RemainAfterExit=yes

[Install]
WantedBy=multi-user.target
SSH_KEY_KEYGEN

# -------------------------------------------------------------- #

	# Inject created content into the new ISO...
	echo -e $GREEN "# Modify the CLI Installer" $ENDCOLOR
	pushd "$TMP_INITRD_DIR" || echo -e $RED "failed to enter init directory: $TMP_INITRD_DIR" $ENDCOLOR
		gzip -d -c "$TMP_DISC_DIR/install.amd/initrd.gz" > "./initrd"
		echo "./preseed.cfg" | fakeroot "$BIN_CPIO" -o -H newc -A -F "./initrd"
		echo "./task.sh" | fakeroot "$BIN_CPIO" -o -H newc -A -F "./initrd"
		find ./custom | fakeroot "$BIN_CPIO" -o -H newc -A -F ./initrd
		cat ./initrd | gzip -9c > "$TMP_DISC_DIR/install.amd/initrd.gz"
		rm "$TMP_INITRD_DIR/initrd"

		echo -e $GREEN "# Modify the GTK Installer" $ENDCOLOR
		gzip -d -c  "$TMP_DISC_DIR/install.amd/gtk/initrd.gz"  > "./initrd"
		echo "./preseed.cfg" | fakeroot "$BIN_CPIO" -o -H newc -A -F "./initrd"
		echo "./task.sh" | fakeroot "$BIN_CPIO" -o -H newc -A -F "./initrd"
		find "./custom" | fakeroot "$BIN_CPIO" -o -H newc -A -F "./initrd"
		cat "./initrd" | gzip -9c > "$TMP_DISC_DIR/install.amd/gtk/initrd.gz"
	popd || (echo -e $RED "Failed to popd" $ENDCOLOR & rtd_oem_pause 1)
	rtd_oem_setup_brand_splash_screen
}



create_iso_image_debian ()
{
# Function to generate the new ISO file from the extracted and
# altered original ISO.
# Delete old iso file if there...
#
# End of Documentation


	echo "------ CREATING ISO: $TARGET_ISO    --------"
	if [ -f "$TARGET_ISO" ]; then
		rm -f "$TARGET_ISO"
	fi

	cd "$TMP_DISC_DIR" || echo "Failed to enter $TMP_DISC_DIR"
	rm -r '[BOOT]'
	"$BIN_XORRISO" -as mkisofs -r -V "$VOLUME_TITLE" -J -b "isolinux/isolinux.bin" -c boot.cat -no-emul-boot -boot-load-size 4 -boot-info-table -input-charset utf-8 -isohybrid-mbr "$ISOHDPFX_BIN" -eltorito-alt-boot -e boot/grub/efi.img -no-emul-boot -isohybrid-gpt-basdat -o "$TARGET_ISO" ./
	chmod 777 "$TARGET_ISO" || read -p "An error may have occurred (review above outout) then: Press [ENTER] to continue:"

	# Test the created ISO file by booting it in a temporary VM using qemu.
	if ($RTD_GUI --title "Media Creation Complete" --yesno "Created $TARGET_ISO . Would you like to test you ISO file?" 10 80); then
    		echo "TESTING $TARGET_ISO."
		check_dependencies qemu-kvm
		"$BIN_QEMU_IMG" create -f qcow2 "$PUT_QCOW_FILE_HERE_WHEN_DONE/$(basename $TARGET_ISO .iso).qcow2" 10G
		qemu-system-x86_64 -smp 2 -enable-kvm -m 4G --cdrom "$PUT_ISO_FILE_HERE_WHEN_DONE/$(basename $TARGET_ISO .iso).iso" "$PUT_QCOW_FILE_HERE_WHEN_DONE/$(basename $TARGET_ISO .iso).qcow2"
	else
    		echo "User selected No, exit status was $?."
	fi
}






make_kvm_virtual_machine_now_from_debian_org ()
{
# Function to create a KVM virtual michine disk and define a VM. This function should be
# used on a Qemu/KVM virtual host that the virtual guest is to be used on.
# NOTE: QCOW2 is a storage format for virtual .
# machine disk images QCOW stands for QEMU copy on write. The QCOW2 format decouples the physical storage
# layer from the virtual layer by adding a mapping between logical and physical blocks.
# NOTE2: Kernel-based Virtual Machine (KVM) is an open source virtualization technology built into LinuxÂ®.
# Specifically, KVM lets you turn Linux into a hypervisor that allows a host machine to run multiple,
# isolated virtual environments called guests or virtual machines (VMs). KVM is part of Linux.
# For complete info: https://www.redhat.com/en/topics/virtualization/what-is-KVM
# set -e
# Use the check_dependencies function to make sure the needed software is available.
# Usage: Either simply call this function to use the defaults or:
# Call this function with "function" "RAM_SIZE" "DISK_SIZE" "DISK_FORMAT" "DISK_FILE"
# Omitting any of the arguments will us the default instead.
#
# End of Documentation

	for i in qemu-utils qemu-tools qemu-kvm qemu-system-x86
	do
		check_dependencies $i 
	done

	# Lookup specific binaries: use full path since they may just have been added and not in $PATH yet.
	: "${BIN_VIRT_INSTALL:=$(type -p virt-install)}"

	# Discover if the appropriate VM net interface is (default or br'0 - n')
	VIRT_NET="$(if ls /sys/class/net |grep br |grep -v virbr >/dev/null; then echo "bridge:$(ls /sys/class/net)" |grep br ; else echo default;fi)"
	
	# create image and run installer
	"${BIN_VIRT_INSTALL}" --name VDI_Debian_"$CONFIG"_"$RANDOM" \
		--vcpus "${2:-2}" \
		--memory "${3:-2048}" \
		--network "$VIRT_NET" \
		--location=http://ftp.us.debian.org/debian/dists/buster/main/installer-amd64/  \
		--disk size="${4:-20}" \
		--os-variant="${1:-debian10}" \
		--initrd-inject="$PRESEED_FILE" \
		--initrd-inject="$TASK_FILE" \
		--extra-args "ks=file:/$(basename $PRESEED_FILE)" \
		--noautoconsole || read -p "An ERROR has occurred. Please press [ENTER] to continue..."
		#"$RTD_GUI" --backtitle "$BRANDING" --title "NOTICE!" --msgbox "ERROR: -- Building VM using $PRESEED_FILE and internal instruction: ks=file:/$(basename $PRESEED_FILE) Options given were: $1 $2 $3 $4" 10 60
	$RTD_GUI --backtitle "$BRANDING" --title "NOTICE!" --msgbox "The virtual machine is currently being built. You may attach to this server and see the progress at IP: $(hostname -I))" 10 60
}







make_kvm_virtual_machine_now_from_ubuntu_com ()
{
# Function to create a KVM virtual michine disk and define a VM. This function should be
# used on a Qemu/KVM virtual host that the virtual guest is to be used on.
# NOTE: QCOW2 is a storage format for virtual .
# machine disk images QCOW stands for QEMU copy on write. The QCOW2 format decouples the physical storage
# layer from the virtual layer by adding a mapping between logical and physical blocks.
# NOTE2: Kernel-based Virtual Machine (KVM) is an open source virtualization technology built into LinuxÂ®.
# Specifically, KVM lets you turn Linux into a hypervisor that allows a host machine to run multiple,
# isolated virtual environments called guests or virtual machines (VMs). KVM is part of Linux.
# For complete info: https://www.redhat.com/en/topics/virtualization/what-is-KVM
# set -e
# Use the check_dependencies function to make sure the needed software is available.
# Usage: Either simply call this function to use the defaults or:
# Call this function with "function" "RAM_SIZE" "DISK_SIZE" "DISK_FORMAT" "DISK_FILE"
# Omitting any of the arguments will us the default instead.
#
# End of Documentation

	for i in qemu-utils qemu-tools qemu-kvm qemu-system-x86
	do
		check_dependencies $i 
	done

	# Lookup specific binaries: use full path since they may just have been added and not in $PATH yet.
	: "${BIN_VIRT_INSTALL:=$(type -p virt-install)}"

	# Discover if the appropriate VM net interface is (default or br'0 - n')
	VIRT_NET="$(if ls /sys/class/net |grep br |grep -v virbr >/dev/null; then echo "bridge:$(ls /sys/class/net)" |grep br ; else echo default;fi)"
 
	# create image and run installer
	"${BIN_VIRT_INSTALL}" --name VDI_Ubuntu_"$CONFIG"_"$RANDOM" \
		--vcpus "${2:-2}" \
		--memory "${3:-2048}" \
		--network "$VIRT_NET" \
		--disk size="${4:-20}" \
		--os-variant="${1:-debian10}" \
		--location=http://us.archive.ubuntu.com/ubuntu/dists/focal/main/installer-amd64/ \
		--initrd-inject="$PRESEED_FILE" \
		--initrd-inject="$TASK_FILE" \
		--extra-args "ks=file:/$(basename $PRESEED_FILE)" \
		--noautoconsole || read -p "An ERROR has occurred. Please press [ENTER] to continue..."
		#"$RTD_GUI" --backtitle "$BRANDING" --title "NOTICE!" --msgbox "ERROR: -- Building VM using $PRESEED_FILE and internal instruction: ks=file:/$(basename $PRESEED_FILE) Options given were: $1 $2 $3 $4" 10 60
		#
	$RTD_GUI --backtitle "$BRANDING" --title "NOTICE!" --msgbox "The virtual machine is currently being built. You may attach to this server and see the progress at IP: $(hostname -I))" 10 60
}








make_kvm_virtual_machine_now_from_iso ()
{
# Function to create a KVM virtual michine disk and define a VM. This function should be
# used on a Qemu/KVM virtual host that the virtual guest is to be used on.
# NOTE: QCOW2 is a storage format for virtual .
# machine disk images QCOW stands for QEMU copy on write. The QCOW2 format decouples the physical storage
# layer from the virtual layer by adding a mapping between logical and physical blocks.
# NOTE2: Kernel-based Virtual Machine (KVM) is an open source virtualization technology built into LinuxÂ®.
# Specifically, KVM lets you turn Linux into a hypervisor that allows a host machine to run multiple,
# isolated virtual environments called guests or virtual machines (VMs). KVM is part of Linux.
# For complete info: https://www.redhat.com/en/topics/virtualization/what-is-KVM
# set -e
# Use the check_dependencies function to make sure the needed software is available.
# Usage: Either simply call this function to use the defaults or:
# Call this function with "function" "RAM_SIZE" "DISK_SIZE" "DISK_FORMAT" "DISK_FILE"
# Omitting any of the arguments will us the default instead.
#
# End of Documentation

	for i in qemu-utils qemu-kvm qemu-system-x86
	do
		check_dependencies $i || $RTD_GUI --backtitle "$BRANDING" --title "NOTICE!" --msgbox "$i is missing from this computer; and I could not install it either..." 10 60
	done

	# Lookup specific binaries: use full path since they may just have been added and not in $PATH yet.
	: "${BIN_QEMU_IMG:=$(type -P qemu-img)}"
	: "${BIN_KVM:=$(type -P kvm)}"
	: "${BIN_QEMU_SYSTEM_X86_64:=$(type -P qemu-system-x86_64 )}"
	: "${BIN_VIRT_INSTALL:=$(type -p virt-install)}"

	#Verify ISO presesnce
		if [[ ! -f "$TARGET_ISO" ]]; then
			$RTD_GUI --backtitle "$BRANDING" --title "NOTICE!" --msgbox "OOOPS! I cannot find the ISO image to build the VM... " 10 60
			show_main_menu
		fi

	# create image and run installer
	virt-install --name VM_Template_"$1"_"$RANDOM" --vcpus "${"2"}" --memory "${"2048"}" --network default --cdrom="$TARGET_ISO" --disk size="${"20"}" --os-variant="${1:-"debian10"}"
	$RTD_GUI --backtitle "$BRANDING" --title "NOTICE!" --msgbox "The virtual machine is currently being built. You may attach to this server and see the progress at IP: $(hostname -I)" 10 60
}












create_iso_image ()
{
# Function to generate the new ISO file from the extracted and
# altered original ISO.
# Delete old iso file if there...
#
# End of Documentation


	echo "------ CREATING ISO: $TARGET_ISO    --------"
	if [ -f "$TARGET_ISO" ]; then
		rm -f "$TARGET_ISO"
	fi

	cd "$TMP_DISC_DIR" || echo "failed to enter $TMP_DISC_DIR "
	rm -r '[BOOT]'
	"$BIN_XORRISO" -as mkisofs -r -V "$VOLUME_TITLE" -J -b isolinux.bin -c boot.cat -no-emul-boot -boot-load-size 4 -boot-info-table -input-charset utf-8 -isohybrid-mbr "$ISOHDPFX_BIN" -eltorito-alt-boot -e boot/grub/efi.img -no-emul-boot -isohybrid-gpt-basdat -o "$TARGET_ISO" ./
	chmod 777 "$TARGET_ISO" || read -p "An error may have occurred (review above outout) then: Press [ENTER] to continue:"
}








ensure_admin ()
{
# Function to elevate priviledges of script execution and to ensure administrative privileges 
# such that system wide settings or configuration may be done. 
# 
# The function expects no arguments, but will prompt for system password if required. 
# Usage: 
# ensure_admin
#    
# End of documentation

	if [ "$UID" -eq 0 ]; then
		write_warning "This script needs administrative access..." 
		sudo bash "$0" "$*"
		exit 
	else 
		if xset q &>/dev/null; then xhost local:root ; fi
	fi
}



rtd_oem_check_inet_access ()
{
# Function to verrify internet availabiltiy. 
# The funciton will pause for 10 seconds by default, and will accept 
# an integer to indicate a non-decault time to pause. 
# Usage:
# rtd_oem_check_inet_access [ integer ]
#     
# Example:
# rtd_oem_check_inet_access 60
#   
# If an argument is omitted rtd_oem_check_inet_access will wait indefinitley
# for input. 
# 
# End of documentation
	_ARG=$1
	if ! hash curl &>/dev/null; then 
		read -t 10 -p "N O T I C E ! --  Could not check for internet connectivity... Please install (curl) web crawler/downloader. Press [ENTER] to continue and [CTRL] + [C] to exit! Continuing in 10 seconds..." 
	else
		if [[ -z "$_ARG" ]]; then 
			curl ipinfo.io &>/dev/null || ( read -p "N O T I C E ! -- NO INTERNET ACCESS: This script may require access to the internet to work properly! Press [ENTER] to continue and [CTRL] + [C] to exit!  " )
		else	
			curl ipinfo.io &>/dev/null || ( read -t ${1:-10} -p "N O T I C E ! -- NO INTERNET ACCESS: This script may require access to the internet to work properly! Press [ENTER] to continue and [CTRL] + [C] to exit!  Continuing in ${1:-10} seconds..." )
		fi
	fi
}



rtd_oem_kde_set_wallpaper ()
{
# rtd_oem_kde_set_wallpaper
# Function to set KDE Plasma wallpaper from a script. this function expects one variable 
# indication what file to set as background. You must provide the full path to the file. 
# rtd_oem_kde_set_wallpaper /opt/oem/wallpaper.png Supported fule types are: 
# webm, mp4, png, jpeg, gif, webp. 
# End of documentation

	echo "Setting wallpaper $1" 
	full_image_path=$(realpath "$1")
	ext=$(file -b --mime-type "$full_image_path")

	if [ -z "$2" ]; then
	# Identify filetype and make changes
	case $(echo $ext | cut -d'/' -f2) in
		"mp4"|"webm") type='VideoWallpaper' ; write='VideoWallpaperBackgroundVideo';;
		"png"|"jpeg") type='org.kde.image' ; write='Image' ;;
		"gif"|"webp") type='GifWallpaper' ; write="GifWallpaperBackgroundGif" ;;
	esac
	else
	type="$2";
	write="$3";
	fi

	wallpaper_set_script="var allDesktops = desktops();
	print (allDesktops);
	for (i=0;i<allDesktops.length;i++)
	{
		d = allDesktops[i];
		d.wallpaperPlugin = '${type}';
		d.currentConfigGroup = Array('Wallpaper', '${type}', 'General');
		d.writeConfig('Image', 'file:///dev/null')
		d.writeConfig('$write', 'file://${full_image_path}')
	}"

	qdbus org.kde.plasmashell /PlasmaShell org.kde.PlasmaShell.evaluateScript "${wallpaper_set_script}"
	kwriteconfig5 --file kscreenlockerrc --group Greeter --group Wallpaper --group org.kde.image --group General --key Image "file://$full_image_path"
}




rtd_oem_remove_non_western_latin_fonts ()
{
# rtd_oem_remove_non_western_latin_fonts: a simple function to remove known
# non-western (latin) fonts from a distribution. Notably, Ubuntu provides too many fonts
# of all kinds by default, even if the user will never need the fonts. However, the fonts
# may cause unexpected font tool behavior and crashes, due to the large number of fonts 
# and their features. It is there fore a good Idea to remove these fonts if they are not needed.
# Usage: 
#	Simply call this function by stating its name:
# 	rtd_oem_remove_non_western_latin_fonts
# 	
# The function will not return any sucess or failure codes. It will do its best and exit.
# End of documentation

	font_list="fonts-kacst fonts-kacst-one fonts-khmeros-core fonts-lklug-sinhala fonts-lohit-guru fonts-guru fonts-nanum fonts-noto-cjk fonts-takao-pgothic fonts-tibetan-machine fonts-guru-extra \
		fonts-lao fonts-sil-padauk fonts-sil-abyssinica fonts-tlwg-* fonts-beng fonts-beng-extra fonts-deva fonts-deva-extra fonts-gubbi fonts-gujr fonts-gujr-extra fonts-kalapi fonts-knda \
		fonts-lohit-* fonts-noto-* fonts-orya* fonts-pagul fonts-sahadeva fonts-samyak-* fonts-sarai fonts-smc fonts-smc-* fonts-taml fonts-telu fonts-telu-extra"
	echo "Attempting to remove non-western fonts..."
	count=0
	for i in $font_list ; do 
		rtd_oem_remove_software $i &>/dev/null && (( count++))
	done
	echo "Removed [ $count ] non-western Fonts"
}



rtd_oem_remove_software ()
{
# rtd_oem_remove_software
# The OEM remove software function will attempt to remove whatever package name given
# as an argument using whatever package system found on the system. This is provided 
# for portability and convenience. Currently, this functions will attempt to use
# pkcon (prefferred as it run on many distributions), apt, yum, dnf, and zypper. 
# Additional package manager may be added as time allows. 
# Usage: 
# 	call this function using one argument only for reliability reasons; 
#	as per the below example. If thre is a need to remove a large number of
#	packages it is reccommended to use a for loop and call this function, 
#	still realizing the benefit of mylti-distribution support.
#
#	rtd_oem_remove_software packagename
#
# If a failure occurs this function will return a non "0" exit code. (1)
# End of documentation

	if [[ $(echo $OSTYPE |grep "linux") ]]; then
		echo "Trying to remove package $*"
		if hash dnf 2>/dev/null; then
			dnf -y remove $*
			return $?
		elif hash yum 2>/dev/null; then
			yum -y remove $*
			return $?
		elif hash zypper 2>/dev/null; then
			zypper -y remove $*
			return $?
		elif hash apt 2>/dev/null; then
			apt-get -y remove $* && apt -y autoremove
			return $?
		elif hash pkcon 2>/dev/null; then
			pkcon remove $* -y --autoremove
			return $?
		else
			echo -e $YELLOW "This system does not seem to have a software managment system" $ENDCOLOR
			return 1
		fi
	elif [[ "$OSTYPE" == "freebsd"* ]]; then
		echo "Free BSD is currently unsupported... "
		return 1
	else
		echo "Though you can run bash, I have no Idea how to remove software here!"
		return 1
	fi
}





set_install_command ()
{
# set_install_command
# add global install command for portability and convenience
# If you need to use this script in an rpm based system you could modify the install
# command here to suit dnf, yum, zypper... By default packages of patternd that do not
# match should be skipped. Use "export option" so child processes also see the variiables.
# End of documentation
	if [[ 'echo $OSTYPE" |grep "linux"' ]]; then
		if hash pkcon 2>/dev/null; then
			# If package kit is available then prefer this
			echo -e $YELLOW "Setting install options for Package Kit" $ENDCOLOR
			export _INSTCMD="pkcon -y  install"
		elif hash yum 2>/dev/null; then
			# If package kit is not available try yum (RedHat, Cent OS, Fedora)
			echo -e $YELLOW "Setting install options for YUM" $ENDCOLOR
			export _INSTCMD="yum -y  install"
		elif hash apt 2>/dev/null; then
			# If package kit is not available try apt (Debian, Ubuntu, and all derivatives)
			echo -e $YELLOW "Setting install options for DEB" $ENDCOLOR
			export _INSTCMD="apt-get -y -qq --allow-change-held-packages --ignore-missing install"
			export DEBIAN_FRONTEND=noninteractive
		elif hash zypper 2>/dev/null; then
			# If package kit is not available try zypper (Open SUSE)
			echo -e $YELLOW "Setting install options for ZYPPER" $ENDCOLOR
			export _INSTCMD="zypper install -y "
		else
			echo -e $YELLOW "This system does not seem to have a software managment system" $ENDCOLOR
			exit 1
		fi

	elif [[ "$OSTYPE" == "freebsd"* ]]; then
		echo "Free BSD is currently unsupported... "
		export _INSTCMD="echo I dont know how to install suff on FreeBSD!"
	else
	echo "I have no Idea what this system is"
		export _INSTCMD="Whatever!"
		exit 1
	fi
}






check_menu_availability ()
{
# First discover what menu system is installed. Some systems use "dialog" and
# other systems use whiptail for the terminal to show menus and dialogs.
# If nothing is found, then make sure it is available before continuing.
# End of documentation
	if hash dialog 2>/dev/null ; then
		: "${RTD_GUI:=dialog --clear}"
		export RTD_GUI
	elif hash whiptail 2>/dev/null ; then
		: "${RTD_GUI:="whiptail --fb"}"
		export RTD_GUI
		if ( $RTD_GUI --backtitle "$BRANDING" --title "System Information Menu" --no-button "NO: Use whiptail" --yes-button "YES: Install dialog" --yesno "Please NOTE that we are using WHIPTAIL as a terminal menu system, which is missing several features compared to the default: DIALOG menu system. There are a few reasons we may be using WHIPTAIL instead: I was forced to use it or it is the only terminal menu system available... If you continue with the current WHIPTAIL some things might not work. \n \n May I please try to install the dialog system in stead? . \n  " 20 90 ); then
			RTD_GUI=dialog
			err_no_menu_system_found
		else
			echo "User selected No, exit status was $?."
		fi
	else
		err_no_menu_system_found dialog && return 1 || exit 1
	fi
}





err_no_menu_system_found ()
{
# Function to handle the error condition if a manu system is not found on the system.
# On occasion it may be neede to display dialog boxes and selection menus even in a terminal.
# for these cases; dialog, whiptail (newt), or zenity may be needed. 
# This function will attempt to install the desired menu system and if it cannot or the user
# opts out it will error and exit the script. 
#
# End of documentation

	echo -e $RED" ______________________________________________________________________ \n There is eiter no way to display menus on this system or you have told me \n to install the default  menu system! \n This is required to display the administrative menus... \n \n     Â¯\_( Í¡ðŸ‘ï¸â€¯ÍœÊ– Í¡ðŸ‘ï¸)_/Â¯ \n ______________________________________________________________________ \n"
	echo -e $YELLOW"May I attepmpt to install this ability to your system? \a $ENDCOLOR"
	read -p "Add software: (y/n)?" choice
	case "$choice" in
	y|Y )
		: "${RTD_GUI:=$1}"
		for i in dnf yum zypper apt-get; do
			if hash $i 2>/dev/null; then
				$i install $RTD_GUI -y 
				if $? eq 0 ;  then 
					echo -e $YELLOW"$RTD_GUI installed... exporting..."
					RTD_GUI="dialog --clear"
					export RTD_GUI
					return 0
				fi
			fi
		done
	;;
	n|N ) err_no_menu_system_available ;;
	* ) read -p  "Invalid Selection" && err_no_menu_system_found || exit 1 ;;
	esac
}







enable_firewall ()
{
# enable_firewall
# Function to enable system firewall and add a given rule. This simple function
# enables Uncomplicated Fire Wall (UFW) and adds a rule to allow SSH to
# pass. This function expects no arguments. However nothing will be done if
# no ufw firewall is present on the system. The cunction will not attempt to add 
# the ufw since this may conflict with any firewall present. To use this funciton 
# to enable ufw, first any other firewall software must be disabled and ufw added.
# End of documentation
	if hash ufw 2>/dev/null; then
			echo -e $YELLOW "Configure Firewall:" $ENDCOLOR
			ufw enable && ufw allow ssh
	else
			echo -e $faded_orange "UFW not present on this system: please turn on the firewall and configure it manually!" $ENDCOLOR
	fi
}





rtd_oem_pause ()
{
# rtd_oem_pause: 
# A simple function to pause and wait for end user input. 
# The function expects a non zero (0) argument to execute the pause 
# and wait for the end user to press ENTER to continue execution.
#  
# Usage suggestion stop on execution error: 
# EXPRESSION  || rtd_oem_pause 1
# or
# EXPRESSION ; rtd_oem_pause $?
#
# in both of these cases script executoi will halt and wait for confirmation
# before continuing. 
# End of documentation

	if [ ! $1 -eq 0 ]; then
		read -p "Press  [ ENTER ] to continue:"
	fi
}






check_if_password_p0wned () {
	pass_str=$($RTD_GUI --passwordbox "Please enter your intended password to validate your new password against P0wned DB" 8 78 --title "" 3>&1 1>&2 2>&3)
	result=$(
		sha1=$(echo -n $pass_str | tr -d '\n' | sha1sum); echo "Hash prefix: ${sha1:0:5}"; echo "Hash suffix: ${sha1:5:35}";
		query_result=$(curl https://api.pwnedpasswords.com/range/${sha1:0:5} 2>/dev/null | grep "$(echo "${sha1:5:35}" | tr '[:lower:]' '[:upper:]')");
		printf "Your password appeared %d times for sale in the Darknet per the P0wned online database...." "${query_result#*:}" 2>/dev/null ;
		unset pass_str ;
		)
	display_result "Password P0wned Status"
}







rtd_update_system ()
{
# rtd_update_system
# System update function. The purpose of this function is to update installed software from
# distribution reopositories and the newer self contained universal software stores like
# snap and flatpak. 
# Function does not expect any argument. However it will respect one argument \"simple\"
# The simple argument instructs this functions [pkcon] action to display simple output
# rather than more user friendly output. 
# Update native software packages; since it is not known what distribution
# this script is being executed on, it is best to check and see if we are able
# to perform an update and then do the update...
# One could choose to check for a supported exact version: e.g. Ubuntu, but we would
# like to be nice and add value for as many as we can. Specially if it is this easy! :)
# End of documentation

	PUBLICATION="$BRANDING Update Manager for Linux"
	VERSION="1.13 (built in)"

	LOGFILE="${LOGFILE:-$0.log}"


	echo -e $GREEN"$PUBLICATION: Version $VERSION" $ENDCOLOR
	echo -e $GREEN"------------------------------------------------" $ENDCOLOR

	echo I am updating software from all channels i can find on the system.
	echo I will update via the native package manager as well as newer formats
	echo -e "like $YELLOW snap $ENDCOLOR and $YELLOW flatpak $ENDCOLOR..."
	echo " "


	log_item ()
	{
		DATE=$(date '+%d/%m/%Y %H:%M:%S');
		echo "$DATE --- : $*" >> "$LOGFILE"
	}


	rtd_software_task ()
	{
		log_item "running rtd_software_task with parameters $*"
		# make some decent display terminal graphics...
		PAD="------------------------------------------"
		LINE=$(printf "%s %s" "$@" "$PAD" | cut -c 1-${#PAD})
		echo -ne "--- Executing $LINE:"\ & "$@" >>"$LOGFILE" 2>&1 && printf "%b%-6s%b [ \xE2\x9C\x94 ] $GREEN OK!$ENDCOLOR   \n" ||printf "%b%-6s%b [ ! ] $RED FAILED $ENDCOLOR  \n"
	}

	if hash pkcon 2>/dev/null; then
		# If package kit is available then prefer this
		if [[ $1 == simple ]]; then disp_option="--plain" ; fi
		echo -e $YELLOW "Using: Package Kit" $ENDCOLOR
		pkcon -y refresh $disp_option 2>> $LOGFILE
		pkcon -y update --autoremove $disp_option 2>> $LOGFILE
	elif hash yum 2>/dev/null; then
		# If package kit is not available try yum (RedHat, Cent OS, Fedora)
		echo -e $YELLOW "Using: YUM" $ENDCOLOR
		rtd_software_task yum -y upgrade 2>> $LOGFILE
	elif hash apt 2>/dev/null; then
		# If package kit is not available try apt (Debian, Ubuntu, and all derivatives)
		echo -e $YELLOW "Using: DEB" $ENDCOLOR
		rtd_software_task apt-get update
		rtd_software_task apt-get upgrade -y
		rtd_software_task apt-get autoremove -y
	elif hash zypper 2>/dev/null; then
		# If package kit is not available try zypper (Open SUSE)
		echo -e $YELLOW "Using: ZYPPER" $ENDCOLOR
		rtd_software_task zypper up -y 2>> $LOGFILE
	else
		echo -e $YELLOW "This system does not seem to have a software managment system" $ENDCOLOR
		exit 1
	fi

	# updating snaps if snap is present on the system...
	if hash snap 2>/dev/null; then
		snap refresh 2>> $LOGFILE
	else
		echo "--- snap software is not present on this system... skipping..."
	fi

	# updating flatpacks if flatpack is present on system...
	if hash flatpak 2>/dev/null; then
		flatpak update -y 2>> $LOGFILE
	else
		echo "--- flatpak software is not present on this system... skipping..."
	fi
}




add_software_task ()
{
# Display executed task and echo ON/NOK based on sucess
# This function is created to reduce the terminal output and create a more poliches output of
# the tasks executed. This function has no idea shat it is doing, it will simply call the function 
# it was asked to call or execute the command ist was asked to, and echo OK or FAIL based on the 
# return code. 
# End of documentation
	PAD="------------------------------------------"
	LINE=$(printf "%s %s" "$@" "$PAD" | cut -c 1-${#PAD})
	echo -ne "Installing "$LINE"":""\ & $@ &>/dev/null && printf "%b%-6s%b [ \xE2\x9C\x94 ] $GREEN OK!$ENDCOLOR   \n" ||printf "%b%-6s%b [ ! ] $RED FAILED $ENDCOLOR  \n"
}







dl ()
{
# Function by Nate Beaken to ease and make consistent the downloading of the non repository packages and
# install them. It can install any package that Package Kit can manage (available on most Linux dists)
# It expects one parameter: the complete URL to download from.
# End of documentation

	download_url="$1"
	fetch_file () { wget -P /opt/rtd/cache "$download_url" 1>>$_LOGFILE 2>>$_ERRLOGFILE ; }

	echo  "    - getting package $download_url ..."
	if hash wget >/dev/null ; then
		fetch_file
	else
		check_dependencies wget
		fetch_file
	fi

	echo "    - Installing package $(basename "$download_url") ..."
	if hash pkcon >/dev/null ; then
		pkcon install-local -y /opt/rtd/cache/"$(basename "$download_url")" 1>>$_LOGFILE 2>>$_ERRLOGFILE
	else
		check_dependencies packagekit-tools
		pkcon install-local -y /opt/rtd/cache/"$(basename "$download_url")" 1>>$_LOGFILE 2>>$_ERRLOGFILE
	fi
}







SofwareManagmentAvailabilityCHK ()
{
# Function to check and see if the system software managment is available. In some cases
# the sofware managment system may be in use. Should this be the case, this function will
# wait undill the system is free for use.
# TODO: Add support for fedora, Centos, SuSE.
# End of documentation
	echo ""
	echo -e $YELLOW"--- Checking if software maintenance system is available:" $ENDCOLOR
	i=0
	tput sc
	while fuser /var/lib/dpkg/lock >/dev/null 2>&1 ; do
		case $(($i % 4)) in
			0 ) j="-" ;;
			1 ) j="\\" ;;
			2 ) j="|" ;;
			3 ) j="/" ;;
		esac    
		tput rc
		echo -en "\r[$j] Waiting for other software managers to finish..."\


		sleep 5
		((i=i+1))
	done
}




rtd_oem_reset_default_environment_config ()
{
# Function to reset temporary configurations to their original setings from the
# distributor. To configure and/or automatically install Linux systems RTD OEM
# load process must make some changes to the system in question that are not
# good security practice or that may be disruptive during normal operations.
# These setings are not limited to bu include "auto login", "auto sudo" and
# "auto running scripts"...
# End of documentation

	# Disable the automatically trying to install OEM software
	[[ -f /etc/xdg/autostart/org.runtimedata.oem.cofig.desktop ]] && mv /etc/xdg/autostart/org.runtimedata.oem.cofig.desktop /opt/rtd/scripts
	[[ -f /etc/sudoers.d/99_sudo_include_file ]] && mv /etc/sudoers.d/99_sudo_include_file /opt/rtd/scripts
	cp /home/$SUDO_USER/.bashrc /opt/rtd/scripts
	sed -i '/xhost\ local:root/d' /home/$SUDO_USER/.bashrc
}




rtd_wait_for_internet_availability ()
{
# Function that, when called, will wait for an active internet connection
# to be available before before continuing. Most softwrare install activities
# need an active internet connection to be able to install and update software.
# Naturally, some in house loads use local mirrors, but if you can see the
# internet, you would have access to your own ropositories as well...
# End of documentation



	echo "Waiting for internet access..."
	echo "NOTE: Free access to the internet is required to continue."
	while ! ping -c 1 -W 1 8.8.8.8 &>/dev/null ; do
		echo Waiting...
		sleep 5
	done
}





up2date ()
{
# Function to simplify updating system completely. At present this function sets the
# highest preference to use "pkcon", the command line interface of "Package Kit" since
# this is the most consistent across different distrbutions. It may even work on BSD.
# Only if "pkcon" is not available, will the function use the identified distro native
# software manager: apt, yum, zypper etc. This is to maintain stability since a distro may
# alias another distributions command (like SuSE does with apt) to be helpfull.
# This is one of the first update functions written and is kept for compatibility.
# End of documentation

	echo -e $YELLOW"--- Running up2date function:" $ENDCOLOR

	if hash pkcon 2>/dev/null; then
		pkcon update -y 		1>>$_LOGFILE 2>>$_ERRLOGFILE
	elif hash yum 2>/dev/null; then
		yum update -y 			1>>$_LOGFILE 2>>$_ERRLOGFILE
	elif hash apt 2>/dev/null; then
		apt-get update 			1>>$_LOGFILE 2>>$_ERRLOGFILE
		apt-get upgrade -y 		1>>$_LOGFILE 2>>$_ERRLOGFILE
		apt-get autoremove -y 		1>>$_LOGFILE 2>>$_ERRLOGFILE
	elif hash zypper 2>/dev/null; then
		return zypper up -y		1>>$_LOGFILE 2>>$_ERRLOGFILE
	else
		return 3
	fi
}






is_software_package_installed ()
{
# Function to check if a piece of software is installed. This function will first check
# if the package manager is deb, zypper or rpm, and then take one parameter passed
# and evauate if a software package by that name is installed. This function
# will return a "0" or "1" return based on the package managers return code.
# Call this function by:
# is_software_package_installed "package name"
#                 or
# is_software_package_installed "$1" if calling this function from a script
# or another function receiving a parameter.
#
# End of documentation

	if hash yum 2>/dev/null; then
		rpm -q "$1" > /dev/null 2>&1 && return 0 || return 1
	elif hash apt 2>/dev/null; then
		dpkg -l "$1" 2>/dev/null |tail -1 |grep "ii  $1" > /dev/null 2>&1 && return 0 || return 1
	elif hash zypper 2>/dev/null; then
		zypper se "$1" > /dev/null 2>&1 && return 0 || return 1
	else
		return 3
	fi
}





is_software_package_available ()
{
# Function to chek if a package is available in whetever repository, and
# if there return a "0" and if not return a "1" or a "3" if there is no recognizable
# package manager found. the function expects the name of the package
# to be a parameter passed to this fuction. Call this function by:
# is_software_package_available "package name"
#                 or
# is_software_package_available "$1" if calling this function from a script
# or another function receiving a parameter.
#
# Supported base distributions: Fedora . SuSE . Debian
# End of documentation

	if hash yum 2>/dev/null; then
		yum list available "$1" &> /dev/null && return 0 || return 1
	elif hash apt 2>/dev/null; then
		apt -qq list "$1" 2>/dev/null | grep -q "$1" && return 0 || return 1
	elif hash zypper 2>/dev/null; then
		return zypper info "$1" &> /dev/null && return 0 || return 1
	else
		return 3
	fi

}





InstallSoftwareFromRepo ()
{
# Function to simplify the installation of software by including all display and
# installation logic for a given software provider. This should be expanded to include flatpack
# snap for example. It should be the same consistent way no matter flavor of Linux.
# This function uses the "$_INSTCMD" to install software. "$_INSTCMD" is defined separatley
# in the "set_install_command" function (a dependency to this function) and could
# be an RPM or deb string, or even snap or flatpack. A preference order between package system and
# snap or flatpack use.
# End of documentation

	# Ask function how to install software... 
	set_install_command >>/dev/null 2>&1

	# make some decent display terminal Graphics...
	PAD="------------------------------------------------"
	LINE=$(printf "%s %s" "$@" "$PAD" | cut -c 1-${#PAD})
	PRE=" - Installing $LINE :"
	# Test if package name is installed, if not then...
	if ! is_software_package_installed "$1"; then
		if is_software_package_available "$1"; then
			echo -ne "$PRE"\ & $_INSTCMD "$1" 1>>$_LOGFILE 2>>$_ERRLOGFILE && printf "%b%-6s%b [ \xE2\x9C\x94 ] $GREEN OK!$ENDCOLOR \n" ||printf "%b%-6s%b [ ! ] $RED FAILED $ENDCOLOR \n"
			if [ $? != 0 ];
			then
				return 1 & exit 1
			fi
		else
			echo -ne "$PRE"\ && printf "%b%-6s%b [ \xE2\x9C\x94 ] $YELLOW NOT AVAILABLE... $ENDCOLOR \n"
		fi
	else
		echo -ne "$PRE"\ && printf "%b%-6s%b [ \xE2\x9C\x94 ] $YELLOW Allready Installed... $ENDCOLOR \n"
	fi
}





check_dependencies ()
{
# Function to check that a piece of software is installed and if not install it.
# Works for apt based systems currently. The function will take a parameter that is expected to
# match the softwre command line name or rather the name of the package. This should get
# updated to also check and install from snap and flatpack.
# End of documentation

	#---------------------------------------------------------------
	echo "Checking for script dependencies and install if not there..."
	#---------------------------------------------------------------
	if is_software_package_installed $1 ; then
		echo -e $GREEN"I found that $1 is present on this system... thankyou for that! " $ENDCOLOR
	else
		echo -e $YELLOW"You seem to have no $1... I will try to get it... " $ENDCOLOR
		InstallSoftwareFromRepo $1
		if [ $? != 0 ];
		then
			echo -e $RED "That install didn't work out so well."
			echo -e "Please manually try to add the software since I couldn't do it." $ENDCOLOR
			exit
		fi
		echo "OK Done! Continuing..."
	fi
}





system_update ()
{
# Function to update the Linux based system. This function is universal for all
# distributions that have package kit available. It works in the same manner on
# RedHat/Fedora, Debian/Ubuntu and all their derivatives. When invoked as a
# part in a script, it is wist to ensure that the package kit is available
# by using the "check_dependencies" function to ensure that the software is available.
# End of documentation

    if hash pkcon 2>/dev/null; then
    	pkcon refresh
	pkcon update -y
    else
	echo "You seem to have now Package Kit... I will try to get it... "
	echo "I will need to become admin to do that..."
	sudo check_dependencies packagekit
	    if [ $? != 0 ];
	    then
		echo "That install didn't work out so well."
		echo "Defaulting to the onld Up2Date Function"
		up2date
	    fi
	echo "OK trying again!"
    	pkcon refresh
	pkcon update -y
    fi
}








backup_running_vm ()
{
# Function to back up all funning virtual machines on the host it is being run on.
# This function should be called from within this script and down not require any
# parameters passed.
# End of documentation

	do_vm_backup () {
		echo "Atempting backup of the folloing VM's:"
		virsh list
		# To exclude a VM (domain), add "nobackup" to its name and it will be ignored.
		# To rename: shutdown the guest, then use this command: virsh domrename "oldname" "newname".

		DATE=$(date +%Y-%m-%d.%H:%M:%S)
		LOG="/var/log/kvm-backup.$DATE.LOG"
		BACKUPROOT=${VM_BACKUP_TARGET:=/mnt/vmdsk/VM_BACKUP}

		#Get list of all running virtual machines
		DOMAINS=$(virsh list --all | tail -n +3 | awk '{print $2}')

		for DOMAIN in $DOMAINS; do
			echo "-----------WORKER START $DOMAIN-----------" > $LOG
			echo "Starting backup for $DOMAIN on $(date +'%d-%m-%Y %H:%M:%S')"  >> $LOG

			if [[ $DOMAIN == *"nobackup"* ]];then
				echo "Skipping $DOMAIN , because its excluded." > $LOG
				exit 1
			fi

			VMSTATE=$(virsh list --all | grep $DOMAIN | awk '{print $3}')
			if [[ $VMSTATE != "running" ]]; then
				echo "Skipping $DOMAIN , because its not running." > $LOG
				exit 1
			fi

			BACKUPFOLDER=$BACKUPROOT/KVM-BACKUPS/$DOMAIN
			if [[ ! -d $BACKUPFOLDER ]] ; then
				$RTD_GUI
			fi
			mkdir -p "$BACKUPFOLDER"
			TARGETS="$(virsh domblklist "$DOMAIN" --details | grep disk | awk '{print $3}')"
			IMAGES="$(virsh domblklist "$DOMAIN" --details | grep disk | awk '{print $4}')"
			DISKSPEC=""
			for TARGET in $TARGETS; do
				DISKSPEC="$DISKSPEC --diskspec $TARGET,snapshot=external"
			done

			virsh snapshot-create-as --domain "$DOMAIN" --name "backup-$DOMAIN" --no-metadata --atomic --disk-only "$DISKSPEC" >> "$LOG"
			if [ $? -ne 0 ]; then
				echo "Failed to create snapshot for $DOMAIN" > "$LOG"
				exit 1
			fi

			for IMAGE in $IMAGES; do
				NAME=$(basename $IMAGE)
				if test -f "$BACKUPFOLDER/$NAME"; then
				echo "Backup exists, merging only changes to image" > "$LOG"
				rsync -apvz --inplace "$IMAGE" "$BACKUPFOLDER"/"$NAME" >> "$LOG"
				else
				echo "Backup does not exist, creating a full sparse copy" > "$LOG"
				rsync -apvz --sparse "$IMAGE" "$BACKUPFOLDER"/"$NAME" >> "$LOG"
				fi
			done

			BACKUPIMAGES="$(virsh domblklist "$DOMAIN" --details | grep disk | awk '{print $4}')"
			for TARGET in $TARGETS; do
				if virsh blockcommit "$DOMAIN" "$TARGET" --active --pivot >> "$LOG"; then
					echo "Could not merge changes for disk of $TARGET of $DOMAIN. VM may be in invalid state." > "$LOG"
					exit 1
				fi
			done

			for BACKUP in $BACKUPIMAGES; do
				if [[ $BACKUP == *"backup-"* ]];then

				echo "deleted temporary image $BACKUP" > "$LOG"
				rm -f "$BACKUP"
				fi
			done

			virsh dumpxml "$DOMAIN" > "$BACKUPFOLDER"/"$DOMAIN".xml
			echo "-----------WORKER END $DOMAIN-----------" >> "$LOG"
			echo "Finished backup of $DOMAIN at $(date +'%d-%m-%Y %H:%M:%S')" >> "$LOG"
		done
	}

	if hash virsh ; then
		if ($RTD_GUI --title "Virtual Machine Backup" --yesno "Do you want me to back up these VM's?:
		$(virsh list --all)" 0 $WIDTH ); then
			do_vm_backup
		else
			show_manage_vm_gui
		fi
	else
		if ( $RTD_GUI --title "NOTICE!" --yesno "KVM Virtualization is not installed on this machine. May I attempt to install it for you on this machine?" $HEIGHT $WIDTH ) ; then
			check_dependencies qemu-kvm || ( whiptail --title "ERROR!" --msgbox "KVM install failed!" $HEIGHT $WIDTH & show_manage_vm_gui)  && whiptail --title "Notice!" --msgbox "KVM installation completed!"
			check_dependencies virt-goodies || ( whiptail --title "ERROR!" --msgbox "Virt Goodies install failed!" $HEIGHT $WIDTH & show_manage_vm_gui)  && whiptail --title "Notice!" --msgbox "Virt Goodies installation completed!"
			do_vm_backup
		else
			show_manage_vm_gui
		fi
	fi
}


rtd_ppa_checker ()
{
  for f in /etc/apt/sources.list.d/*.list; do
    grep -Po "(?<=^deb\s).*?(?=#|$)" "$f" | while read -r ENTRY ; do
    echo "ENTRY: $ENTRY"
        HOST=$(cut -d/ -f3 <<< "$ENTRY")

        if [ "ppa.launchpad.net" = "$HOST" ]; then
		USER=$(cut -d/ -f4 <<< "$ENTRY")
		PPA=$(cut -d/ -f5 <<< "$ENTRY")
		packageCount=$(awk '$1=="Package:" {if (a[$2]++ == 0) {system("dpkg -l "$2)}}' /var/lib/apt/lists/*"$USER"*"$PPA"*Packages 2>/dev/null | awk '/^ii/' | wc -l)
		echo "PPA: ppa:$USER/$PPA"
		echo "FILENAME: $f"
		echo "$packageCount package(s) installed"
		if [ "$packageCount" -eq 0 ] && [ "$1" == "--delete" ]; then
			sudo rm "$f" && echo "$f deleted"
		fi
		echo
        else
		USER=$(cut -d/ -f3 <<< "$ENTRY")
		PPA=$(cut -d/ -f4 <<< "$ENTRY")
		packageCount=$(awk '$1=="Package:" {if (a[$2]++ == 0) {system("dpkg -l "$2)}}' /var/lib/apt/lists/*"$USER"*Packages 2>/dev/null | awk '/^ii/' | wc -l)
		echo "REPOSITORY: $USER/$PPA"
		echo "FILENAME: $f"
		echo "$packageCount package(s) installed"
		if [ "$packageCount" -eq 0 ] && [ "$1" == "--delete" ]; then
			sudo rm "$f" && echo "$f deleted"
		fi
		echo
        fi
    done
done
}








rtd_oem_find_live_release()
{
	# This function will return the URL for the version of Debian, Ubuntu server or Destktop requested.
	# 3 parameters are required for this function to know what to do: distro_version/
	# It will also try to read the available iso images and grab the latest or requested iso.
	# Example:
	# Function name 		: distro_version : distro_flavor : live_or_not : desktop_env
	# rtd_oem_find_live_release 	      10              debian         live           kde
	# rtd_oem_find_live_release 	      10              debian         live           cinnamon
	# rtd_oem_find_live_release 	      10              debian         net            ssh-server
	# rtd_oem_find_live_release 	      19.04.2         ubuntu         live
	# End of documentation
	distro_version="${1:-10}"
	distro_flavor="${2:-debian}"
	live_or_not="${3:-live}"
	desktop_env="${4:-standard}"

	case "$distro_flavor" in
	Ubuntu | ubuntu )
		case "$live_or_not" in
		Live | live | current-live | desktop)
			echo "http://releases.ubuntu.com/$distro_version/$(curl --silent http://releases.ubuntu.com/$distro_version/SHA256SUMS | \grep -o 'ubuntu-.*-desktop-amd64.iso')"
		;;
		server | netinst | net | mini )
			# 18.04 and later need to use the alternative installer
			# since the switch to subiquity
			if [ ${1:0:2} -ge 18 ]; then
				echo "http://cdimage.ubuntu.com/releases/$distro_version/release/ubuntu-$distro_version-live-server-arm64.iso"
			else
				rel=http://releases.ubuntu.com/$1
				echo "$rel/$(curl --silent $rel/MD5SUMS | \grep -o 'ubuntu-.*-server-amd64.iso')"
			fi
		;;
		* )
			$RTD_GUI --backtitle "$BRANDING" --title "ERROR!" --msgbox "You passed the function ${FUNCNAME[0]} the parameters $*. The 4th parameter should be either of: Live | live | current-live | server | netinst | net | mini! Not $live_or_not" 10 60
		;;
		esac
	;;
	Debian | debian)
		case "$live_or_not" in
		Live | live | current-live )
			# Debian renames the current iso images for each release. To get around this when downloading
			# the vesion number must be ignored and the desired flavor of the iso should be grabed.
			case "$desktop_env" in
			kde | gnome | xfce | cinnamon | lxde | lxqt | mate | standard )
				rel=https://cdimage.debian.org/debian-cd/current-live/amd64/iso-hybrid/
				echo "$rel/$(curl --silent $rel/MD5SUMS | \grep -o "debian-.*$desktop_env*.iso")"
			;;
			* )
				$RTD_GUI --backtitle "$BRANDING" --title "ERROR!" --msgbox "You passed the function ${FUNCNAME[0]} the parameters $*. The 4th parameter should be wither of: kde | gnome | xfce | cinnamon | lxde | lxqt | mate | standard! Not $live_or_not " 10 60
			;;
			esac
		;;
		netinst | net | mini )
			# Find and download mini iso...
		;;
		* )
			$RTD_GUI --backtitle "$BRANDING" --title "ERROR!" --msgbox "You passed the function ${FUNCNAME[0]} the parameters $*. The 2nd parameter should be either of: Live | live | current-live | netinst | net | mini ! not $live_or_not" 10 60
		;;
		esac
	;;
	*)
		$RTD_GUI --backtitle "$BRANDING" --title "ERROR!" --msgbox "You passed the function ${FUNCNAME[0]} the parameters $*. The 2nd parameter should be either of: Ubuntu | ubuntu Debian | debian! not $distro_flavor" 10 60
	;;
	esac
}







rtd_setup_choices_term_fallback ()
{
# Function to display legacy installation options. This will install software that is usefull
# on a really old system, or a remote system only accessible via SSH. This may be a good
# usecase if oyu happen to be in an opressed geographic locaiton where your only option is
# to ssh to a remote server and access email and web that way. Perfomance in these cases
# may be very poor over the internet (as for example with the great firewall of China). In
# Such a case it would be usefull to have the good old CLI software! :)
# End of documentation

	# List Options to be available for choice in the RTD System Configurator...
	cmd=(dialog --backtitle "RTD OEM System Builder Configuraton Menu" --title "Terminal Software Options Menu" --separate-output --checklist "We did not find a graphical interface. No matter, you can be productive in the cli environment. Please Select Software and Configuration below:" 22 85 16 )
	options=(1 "Base RTD OEM Software" on
		 2 "Alpine email client" on
		 3 "Vim text editor" on
		 4 "Finch multi protocol chat" on
		 5 "Word Grinder word precessor" on
		 6 "Spreadsheet Calculator" on
		 7 "TPP Presentation Program" on
		 8 "Midnight Commander file manager (Norton Commander)" on
		 9 "Cmus Music Player" on
		 10 "Byobu Terminal Window Manger" on
		 11 "W3M web Browser" on
		 12 "LYNX Web Browser" on
		 13 "Mega.nz command line tools (Mega-CMD)" on
		 14 "Rtorrent torrent download software" off
		 15 "Install the OpenVpn client Software" on
		 16 "Games: Freesweep mine sweep game" on
		 17 "Games: Bastet Tetris Game" on
		 18 "OEM Customizatons" on
		)

			choices=$("${cmd[@]}" "${options[@]}" 2>&1 >/dev/tty)
			clear
			for choice in $choices
			do
			    case $choice in
				1) for i in netstat nmcli htop powertop iftop monit nethogs bmon darkstat ss mtr glances nmap iostat multitail ncdu multitail ; do InstallSoftwareFromRepo $i ; done ;;
				2)  InstallSoftwareFromRepo alpine ;;
				3)  InstallSoftwareFromRepo vim ;;
				4)  InstallSoftwareFromRepo finch ;;
				5)  InstallSoftwareFromRepo wordgrinder ;;
				6)  InstallSoftwareFromRepo sc ;;
				7)  InstallSoftwareFromRepo tpp ;;
				8)  InstallSoftwareFromRepo mc ;;
				9)  InstallSoftwareFromRepo cmus ;;
				10) InstallSoftwareFromRepo byobu ;;
				11) InstallSoftwareFromRepo w3m ;;
				12) InstallSoftwareFromRepo lynx ;;
				13) dl https://mega.nz/linux/MEGAsync/xUbuntu_19.04/amd64/megacmd-*.deb	;;
				14) InstallSoftwareFromRepo rtorrent ;;
				15) InstallSoftwareFromRepo openvpn ;;
				16) InstallSoftwareFromRepo freesweep ;;
				17) InstallSoftwareFromRepo bastet ;;
				18) recipie_OEM_config ;;
			esac
		done
}





cleanup_and_finish ()
{
# Function to remove all temporary file locations left over from building
# the new netinstall ISO etc. and clean  up some variables...
# go back to initial directory
# End of documentation

	cd "$CURRENT_DIR" && echo "returned to $CURRENT_DIR" || echo "No directory to return to... never mind."
	# Cleanup folder structure...
	rm -r "$TMP_DOWNLOAD_DIR"
	rm -r "$TMP_DISC_DIR"
	rm -r "$TMP_INITRD_DIR"
	rm -r "$SCRIPT_DIR/custom"

	if [[  "$1" != "nomessage" ]]; then
		COMPLETION_MESSAGE="	Your ISO image is ready!
		It is placed in the folder: $PUT_ISO_FILE_HERE_WHEN_DONE/

		Next steps:
		- Burn the ISO to a USB (ex: using MULTIBOOT from Pendrive Linux)
		- If you are using Virtual Machines select the ISO as install media
		- Boot from the media created: allow it to install the system
		- login as the temporary user (temporary password: letmein)
		- Adjust passwords for the encrypted volume and login... "

		$RTD_GUI --backtitle "RTD OEM System Builder" --title "DONE" --msgbox "$COMPLETION_MESSAGE" 15 80
	else
		echo "Cleanup..."
	fi

	unset BIN_7Z
	unset BIN_XORRISO
	unset BIN_CPIO
	unset ISOHDPFX_BIN
	unset VOLUME_TITLE
	unset TARGET_ISO_FILE_NAME
	unset SOURCE_ISO_URL
	unset SSH_PUBLIC_KEY_FILE
	unset PRESEED_TEMPLATE
	unset CONFIG
	clear
	return
}




generate_report_disk_space_used_by_directory ()
{
# Function to generate a report for folders' disk space use. 
# This function requres one argument; what root folder to analyse the directories in. 
# This functio will return a report contained in the variable $return that may then be used.
# Example: 
# generate_report_disk_space_used_by_directory /home
# 
# This will generate a report on the disk space per directory in the /home folder.
#
# End of documentation

	DIRS=$( ls $1 )
	store=/$tmp/out.ct
	$RTD_GUI --backtitle "$BRANDING" --title "Generating report for: $1" --gauge "Calculating disk space: this may take some time" $HEIGHT $WIDTH < <(
		echo "Storage Utilization Report:" >>$store
		echo "______________________________" >>$store
		n=$(ls $1 | wc -l ) 
		i=0
		for f in $DIRS
		do
			du -cksh $1/$f 2>/dev/null | grep -v total >>$store
			PCT=$(( 100*(++i)/n ))
			cat <<-EOF
			XXX
			$PCT
			Completed calculation for: "$f"...
			XXX
			EOF
			sleep 1
		done
	)
	total=$(echo ----- >>$store && du -cksh $1 2>/dev/null |grep total >>$store) | $RTD_GUI --backtitle "$BRANDING" --title "Completing report..." --progressbox "Working..." $HEIGHT $WIDTH 
	result="$(cat $store )" ; rm $store
}






make_preseed_cfg ()
{
# Function to write out a debina preeseed file to a location requested by the first parameter.
# Other parameters accepted are CONFIG (multiselect de), SRVFUNC (task "Minecraft" "Tasks")
# some parameters have defaults.
# Example:
# functoin_name          location        config          function
# make_preseed_cfg       /path/to/file   ssh-server      Minecraft
# End of documentation

	SAVETO=$1
	CONFIG=$2
	SRVFUNC=${3:-Tasks}
	PRESEED=preseed.cfg
	PRESEED_FILE="$SAVETO/$PRESEED"
	TASK_FILE="$SAVETO/task.sh"
	echo "Writing installation instructions for [$CONFIG] in $SAVETO/$PRESEED"
	touch "$SAVETO/$PRESEED"

	rtd_oem_preseed_cfg_Unattended_Install "$SAVETO"
	rtd_oem_preseed_cfg_Network_Configuration "$SAVETO"
	rtd_oem_preseed_cfg_Prevent_Install_On_USB "$SAVETO"
	rtd_oem_cfg_Account_Setup "$SAVETO"
	rtd_oem_preseed_cfg_Localization "$SAVETO"
	rtd_oem_preseed_cfg_EFI "$SAVETO"
	rtd_oem_preseed_cfg_GRUB_Bootloader_Installation "$SAVETO"
	rtd_oem_preseed_cfg_Disk_Layout "$SAVETO"
	rtd_oem_preseed_cfg_Package_Selection "$SAVETO" "$CONFIG"
	rtd_oem_cfg_post_task_sequence_default "$SAVETO"
	rtd_oem_preseed_cfg_Addon_"${SRVFUNC}" "$SAVETO"
	rtd_oem_preseed_ubuntu_cfg_KS_CFG_Options "$SAVETO"
}













#                        ---                                     
#                     -        --                             
#                 --( /     \ )XXXXXXXXXXXXX                   
#             --XXX(   O   O  )XXXXXXXXXXXXXXX-              
#            /XXX(       U     )        XXXXXXX\               
#          /XXXXX(              )--   XXXXXXXXXXX\             
#         /XXXXX/ (      O     )   XXXXXX   \XXXXX\
#         XXXXX/   /            XXXXXX   \   \XXXXX----        
#         XXXXXX  /          XXXXXX         \  ----  -         
# ---     XXX  /          XXXXXX      \           ---        
#   --  --  /      /\  XXXXXX            /     ---=         
#     -        /    XXXXXX              '--- XXXXXX         
#       --\/XXX\ XXXXXX                      /XXXXX         
#         \XXXXXXXXX                        /XXXXX/
#          \XXXXXX                         /XXXXX/         
#            \XXXXX--  /                -- XXXX/       
#             --XXXXXXX---------------  XXXXX--         
#                \XXXXXXXXXXXXXXXXXXXXXXXX-            
#                  --XXXXXXXXXXXXXXXXXX-

#::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
#::::::::::::::                                          ::::::::::::::::::::::
#::::::::::::::    Internal Confgiration Repository      ::::::::::::::::::::::
#::::::::::::::                                          ::::::::::::::::::::::
#::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
#
# Below please find the internally stored and maintained configuration cards.
# When creating Linux installation configurations for use in a virtual envoironment
# or for transferring to physical media to install on a laptop or PC; require
# the creation of preseed and kick start configuration files that "answer" the
# installer's questions. These pieces of configuration files are stored below
# such that they may be applied to the actual configuration file as needed and
# wiht variable instructions, for example: what software to install. Any configuration
# item that needs to be written out to a separate file should be stored in this section.
















rtd_setup_choices_preseed () {
# Function to write out a debina preeseed file to a location requested by the first parameter.
# Other parameters accepted are CONFIG (multiselect de), SRVFUNC (task "Minecraft" "Tasks")
# some parameters have defaults.
# Example:
# functoin_name          location        config          function
# make_preseed_cfg       /path/to/file   ssh-server      Minecraft
# End of documentation

	SAVETO=$1
	CONFIG=$2
	SRVFUNC=$3
	: "${SRVFUNC:-Tasks}"
	: "${PRESEED:=preseed.cfg}"
	PRESEED_FILE="$SAVETO/$PRESEED"
	echo "Writing installation instructions for [$CONFIG] in $SAVETO/$PRESEED"
	touch "$1/$PRESEED"

	cmd=("$RTD_GUI" --backtitle "$BRANDING" --title "VM Auto Answer Setup Questions" --separate-output --checklist "Please preconfiguration components below. You will be prompted to manually add information for sections that you de-select:" "$HEIGHT" "$WIDTH" "$LIST_HEIGHT" )
	options=(1 "rtd_oem_preseed_ubuntu_cfg_KS_CFG_Options" on
		 2 "rtd_oem_preseed_cfg_Unattended_Install" on
		 3 "rtd_oem_preseed_cfg_Network_Configuration" on
		 4 "rtd_oem_preseed_cfg_Prevent_Install_On_USB" on
		 5 "rtd_oem_cfg_Account_Setup" on
		 6 "rtd_oem_preseed_cfg_Localization" on
		 7 "rtd_oem_preseed_cfg_EFI" on
		 8 "rtd_oem_preseed_cfg_GRUB_Bootloader_Installation" on
		 9 "rtd_oem_preseed_cfg_Disk_Layout" on
		 10 "rtd_oem_preseed_cfg_Package_Selection" on
		 11 "rtd_oem_preseed_cfg_Addon_${SRVFUNC}" on
		)

		choices=$("${cmd[@]}" "${options[@]}" 2>&1 >/dev/tty)
		clear
		for choice in $choices
		do
			case $choice in
			1) rtd_oem_preseed_ubuntu_cfg_KS_CFG_Options "$SAVETO" ;;
			2) rtd_oem_preseed_cfg_Unattended_Install "$SAVETO" ;;
			3) rtd_oem_preseed_cfg_Network_Configuration "$SAVETO" ;;
			4) rtd_oem_preseed_cfg_Prevent_Install_On_USB "$SAVETO" ;;
			5) rtd_oem_cfg_Account_Setup "$SAVETO" ;;
			6) rtd_oem_preseed_cfg_Localization "$SAVETO" ;;
			7) rtd_oem_preseed_cfg_EFI "$SAVETO" ;;
			8) rtd_oem_preseed_cfg_GRUB_Bootloader_Installation "$SAVETO" ;;
			9) rtd_oem_preseed_cfg_Disk_Layout "$SAVETO" ;;
			10) rtd_oem_preseed_cfg_Package_Selection "$SAVETO" "$CONFIG" ;;
			11) rtd_oem_preseed_cfg_Addon_"${SRVFUNC}" "$SAVETO" ;;
			esac
		done
}




rtd_oem_cfg_post_task_sequence_default ()
{
# Default opst install script to be inserted in to build media (ISO).
# Script will take care to configure automatic login and execution of 
# the next post configurations script **"rtd-me.sh.cmd"** a unified bootstrap
# script that runs on any bash supported system (BE, Apple OS X, Linux, BSD) 
# as well as Windows Shell script (Winsows NT, XP, 7, 8, 10 etc.) as well 
# as provisions for BATCH (DOS, Windows 3.11, 95, 98, ME). 
# End of documentation
	cat >> $1/task.sh <<-'EOF'
	#!/bin/bash
	#::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
	#::::::::::::::                                          ::::::::::::::::::::::
	#::::::::::::::          Script Settings                 ::::::::::::::::::::::
	#::::::::::::::                                          ::::::::::::::::::::::
	#::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
	# Variables that govern the behavior or the script and location of files are 

	# Base folder structure for optional administrative commandlets and scripts:
	_RTDSCR=$(if [ -f /opt/rtd/scripts ]; then echo /opt/rtd/scripts ; else ( mkdir -p /opt/rtd/scripts & echo  /opt/rtd/scripts ) ; fi )
	_RTDCACHE=$(if [ -f /opt/rtd/cache ]; then echo /opt/rtd/cache ; else ( mkdir -p /opt/rtd/cache & echo  /opt/rtd/cache ) ; fi )
	_RTDLOGSD=$(if [ -f /opt/rtd/log ]; then echo /opt/rtd/log ; else ( mkdir -p /opt/rtd/log & echo  /opt/rtd/log ) ; fi )

	# Location of base administrative scripts and commandlets to get.
	_RTDSRC=https://github.com/vonschutter/RTD-Build/archive/master.zip

	# Determine log file directory
	_LOGFILE=$_RTDLOGSD/$( basename $0).log
	_OEM_USER=tangarora



	#::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
	#::::::::::::::                                          ::::::::::::::::::::::
	#::::::::::::::          Define tasks to complete        ::::::::::::::::::::::
	#::::::::::::::                                          ::::::::::::::::::::::
	#::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

	tell_info() {
		echo "starting post install tasks..." 
		echo "SYSTEM information:"		
		echo "File system information: "  	
		mount 				
		echo "Block Devices: "  		
		lsblk   				
		echo "available space: "  		
		df -h  					
		echo "Process information: "  		
		ps aux 					
	} 



	task_setup_rtd_basics() {
		echo "Linux OS Found: Attempting to get instructions for Linux..." 
		wget -q  $_RTDSRC -P $_RTDCACHE 
		unzip -o -j $_RTDCACHE/master.zip -d $_RTDSCR  -x *.png *.md *.yml *.cmd && rm -v $_RTDCACHE/master.zip
		echo "Instructions sucessfully retrieved..." 
		chmod +x $_RTDSCR/* 
		pushd /bin
		ln -f -s $_RTDSCR/rtd* . 		
		popd
	}


	task_setup_ssh_keys() {
		mkdir  -p --mode=0700 /root/.ssh && cat /opt/rtd/custom/userkey.pub > /root/.ssh/authorized_keys 
		mkdir --mode=0700 /home/tangarora/.ssh && cat /opt/rtd/custom/userkey.pub > /home/tangarora/.ssh/authorized_keys 
		chown -R tangarora /home/tangarora/.ssh && chmod 0700 -R /home/tangarora/.ssh 
	}



	task_setup_oem_run_once() {
		# Task to run the OEM post configuaration on first login. 
		# the OEM post configuration may allow for interaction if desired and would
		# best run on several distributions and in a full graphic environment. 

		cat << CREATE_START_LINK > /etc/xdg/autostart/org.runtimedata.oem.cofig.desktop
		# This will automatically start the RuntTime Data OEM config options on 
		# the first login. Once run this launcher will be moved to the /opt/rtd folder
		# so that subsequent logins will not be plagued by the OEM setup.
		# 
		[Desktop Entry]
		Type=Application
		Exec=sudo /opt/rtd/scripts/rtd-oem-linux-config.sh
		Terminal=true
		Hidden=false
		X-GNOME-Autostart-enabled=true
		Name=RuntimeDataConfigurationMenu
		Comment=OEM
		CREATE_START_LINK

	}



	task_enable_oem_elevate_priv() {
		# Add instruction to a sudoers include file:
		# This should be removed when OEM setup is complete as it would represent a back door... 
		echo "tangarora ALL=(ALL) NOPASSWD:ALL" >> /etc/sudoers.d/99_sudo_include_file

		# Check that your sudoers include file passed the visudo syntax checks:
		sudo visudo -cf /etc/sudoers.d/99_sudo_include_file
	}



	task_ensure_oem_auto_login() {
		# task to ensure that the temporary OEM user is loged in for 
		# admin purposes. It is better to install crtail software at this 
		# time since a full graphic environment is avaliable. Also the 
		# step 2 inst the OEM load process is optimally able to run 
		# on several distributions. 


		if [[ -f /etc/lightdm/lightdm.conf ]]; then 
			cp /etc/lightdm/lightdm.conf /etc/lightdm/lightdm.conf.rtd-bak

			cat << OEM_LXDM_LOGIN_OPTION > /etc/lightdm/lightdm.conf
			# This configuration file was created by RTD Setup.
			# You may safely replace this file with the original backed up: 
			# /etc/lightdm/lightdm.conf.rtd-bak
			# If this file is not there, then it wa not there to begin with
			# and you can delete this file. 
			[SeatDefaults]
			autologin-user=$_OEM_USER
			autologin-user-timeout=0
			OEM_LXDM_LOGIN_OPTION

		fi


		if [[ -f /etc/sddm.conf ]]; then 
			cp /etc/sddm.conf /etc/sddm.conf.rtd-bak

			cat << OEM_SDDM_LOGIN_OPTION > /etc/sddm.conf
			# This configuration file was created by RTD Setup.
			# You may safely replace this file with the original backed up: 
			# /etc/sddm.conf.rtd-bak
			# If this file is not there, then it wa not there to begin with
			# and you can delete this file. 
			[Autologin]
			User=$_OEM_USER
			Session=plasma.desktop
			OEM_SDDM_LOGIN_OPTION

		fi


		if [[ -f /etc/gdm3/daemon.conf ]]; then 
			cp /etc/gdm3/daemon.conf /etc/gdm3/daemon.conf.rtd-bak

			cat << OEM_GDM3_LOGIN_OPTION > /etc/gdm3/daemon.conf
			# This configuration file was created by RTD Setup.
			# You may safely replace this file with the original backed up: 
			# /etc/gdm3/daemon.conf.rtd-bak
			# If this file is not there, then it wa not there to begin with
			# and you can delete this file. 
			[daemon]
			AutomaticLoginEnable=True
			AutomaticLogin=$_OEM_USER
			WaylandEnable=false
			OEM_GDM3_LOGIN_OPTION

		fi
	}



	task_oem_ensure_elevated_gui () {
		# Some Debian and other Linux distribution do not allow gui apps to 
		# be run when invoked by "sudo" or in a root (system elevated authority) 
		# environment. To mitigate this some stemp may need to taken. 
		# Will work on Slackware as well as Debian to give root permission to open X programs.
		echo "xhost local:root" >> /home/$_OEM_USER/.bashrc  

		# Allows runing an X program as root
		touch /root/.bashrc
		echo "export XAUTHORITY=/home/$_OEM_USER/.Xauthority" >>/root/.bashrc
	}


	task_oem_autounlock_disk() {
		# Setup automatic unlocking of the encrypted system disk (encryption is default on RTD systems).
		# NOTE: This will render the encryption useless since the key to unlock the encrypted
		# volume will be located on an unencrypted location on the same system as the encrypted volume. 
		# This is the same as locking your door and leaving the key by the door outside. 
		#
		# The intention behind this is to be able to complete all build activites without manual intervention
		# of any kind. The intention is to remove the key file after all administrative tasks are complete. 

		# 1. Back up your initramfs disk
		cp  /boot/initrd.img-$(uname -r)  /boot/initrd.img-$(uname -r).bak

			cat << OEM_CRYPTLOCK_OPTION > /boot/grub/grub.cfg
			### BEGIN /etc/grub.d/10_linux ###
			
			menuentry 'Debian GNU/Linux, with Linux $(uname -r) (crypto safe)' --class debian --class gnu-linux --class gnu --class os {
			      load_video
			      insmod gzio
			      insmod part_msdos
			      insmod ext2
			      set root='hd0,msdos1'
			      search --no-floppy --fs-uuid --set=root 2a5e9b7f-2128-4a50-83b6-d1c285410145
			      echo    'Loading Linux $(uname -r) ...'
			      linux   /vmlinuz-$(uname -r) root=/dev/mapper/dradispro-root ro  quiet
			      echo    'Loading initial ramdisk ...'
			      initrd  /initrd.img-$(uname -r).safe
			}
			...
			## END /etc/grub.d/10_linux ###
			OEM_CRYPTLOCK_OPTION

		# 2. Create the key file in the unencrypted /boot partition
		dd if=/dev/urandom of=/boot/keyfile bs=1024 count=4

		# 3. Set permissions
		chmod 0400 /boot/keyfile

		# 4. Add the new file as unlock key to the encrypted volume
		echo letmein1234 | cryptsetup -v luksAddKey $(blkid | grep crypto_LUKS|  cut -d : -f 1) /boot/keyfile -

		# 6. Edit /etc/crypttab
		chmod 0777 /etc/crypttab
		cp /etc/crypttab /etc/crypttab.temporary
		sed -i /"$(cat /etc/crypttab | cut -d " " -f 1 )"/d /etc/crypttab.temporary 
		echo $(cat /etc/crypttab | cut -d " " -f 1-2)  /$(udevadm info $(blkid | grep crypto_LUKS|  cut -d : -f 1) |grep by-uuid | cut -d : -f 2 | head -1):/keyfile luks,keyscript=/lib/cryptsetup/scripts/pa$  >> /etc/crypttab.temporary
		mv /etc/crypttab /etc/crypttab.back
		mv /etc/crypttab.temporary /etc/crypttab

		# Restore permissions to crypttab
		chmod 0440 /etc/crypttab

		# Generate new initramfs
		mkinitramfs -o /boot/initrd.img-$(uname -r)  $(uname -r)

	}


	task_rtd_oem_reseal () {

		if cat /etc/os-release |grep ubuntu ; then
			InstallSoftwareFromRepo oem-config
		elif cat /etc/os-release |grep debian ; then
			echo "I dont know of any OEM configuration for Debian"
		elif cat /etc/os-release |grep suse ; then
			echo "I dont know of any OEM configuration for SuSE"
		elif cat /etc/os-release |grep fedora ; then
			echo "I dont know of any OEM configuration for Fedora"	
		fi
	}




	#::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
	#::::::::::::::                                          ::::::::::::::::::::::
	#::::::::::::::          Execute tasks                   ::::::::::::::::::::::
	#::::::::::::::                                          ::::::::::::::::::::::
	#::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

	tell_info			&>> $_LOGFILE
	task_setup_rtd_basics		&>> $_LOGFILE
	task_setup_ssh_keys		&>> $_LOGFILE
	task_setup_oem_run_once		&>> $_LOGFILE
	task_enable_oem_elevate_priv	&>> $_LOGFILE
	task_ensure_oem_auto_login	&>> $_LOGFILE
	task_oem_ensure_elevated_gui	&>> $_LOGFILE
	task_rtd_oem_reseal		&>> $_LOGFILE
	#task_oem_autounlock_disk	&>> $_LOGFILE

	EOF
}




rtd_oem_preseed_ubuntu_cfg_KS_CFG_Options ()
{

	cat $1/preseed.cfg >$1/ks.cfg 
		#<<- EOF

		# # --------------------------------------------------- #
		# # KS.CFG Options
		# # --------------------------------------------------- #
		# # Simple instruction to tell the Ubuntu installer that
		# # this is intended to be an unattended install and to only
		# # ask critical questions (wich we will answer in this file)
		# # Add options here from these instructions:
		# #
		# # https://pykickstart.readthedocs.io/en/latest/kickstart-docs.html#chapter-2-kickstart-commands-in-fedora
		# #
		# # Please note that some options in kickstart are superceeded by preseed.
		# #
		# # End of documentation
		# lang en_US.UTF-8
		# keyboard se
		# install
		# cdrom
		# bootloader --location=mbr
		# zerombr yes
		# clearpart --all --initlabel
		# skipx
		# text
		# ubiquity ubiquity/success_command string \
		#  	mkdir -p /target/opt/rtd/scripts ;\
		#  	mkdir -p /target/opt/rtd/log ;\
		#  	cp -r /task.sh /target/opt/rtd/scripts/ ;\
		#  	cp /preseed.cfg /target/opt/rtd/log/ ;\
		#  	chmod +x /target/opt/rtd/scripts/task.sh ;\
		#  	/bin/bash /target/opt/rtd/scripts/task.sh;\
		# 	read -p "Press any key to continue...."
		
		# # --------------------------------------------------- #

	#EOF
}


rtd_oem_preseed_cfg_Unattended_Install ()
{
	cat >> $1/$PRESEED <<-'EOF'

		# --------------------------------------------------- #
		# Unattended Installation
		# --------------------------------------------------- #
		# Simple instruction to tell the debian installer that
		# this is intended to be an unattended install and to only
		# ask critical questions (wich we will answer in this file)
		# End of documentation
		d-i auto-install/enable boolean true
		d-i debconf/priority select critical
		# --------------------------------------------------- #

	EOF
}


rtd_oem_preseed_cfg_Network_Configuration ()
{
	cat >> $1/$PRESEED <<-'EOF'

		# --------------------------------------------------- #
		# Network configuration
		# --------------------------------------------------- #
		# Network setup. This can be a static setup or dhcp.
		# The RTD default prefferred config is to rely on DHCP,
		# and for wireless networks (systems with only wireless cards)
		# default to an SSID named "loader" and the guest wpa string
		# "letmein1234". This allows supported systems to be 
		# installed directly over WiFi with no user input. 
		# End of documentation
		d-i netcfg/choose_interface select manual
		d-i netcfg/hostname string RTD-Client
		d-i netcfg/get_hostname string unassigned-hostname
		d-i netcfg/get_domain string unassigned-domain
		d-i hw-detect/load_firmware boolean true

		# We want the preconfiguration file to work on systems both with and
		# without sucessful dhcp configuration
		d-i netcfg/dhcp_failed note
		d-i netcfg/dhcp_options select Configure network manually
		# d-i netcfg/dhcp_timeout string 60

		d-i netcfg/wireless_show_essids select manual
		d-i netcfg/wireless_essid string loader
		d-i netcfg/wireless_essid_again string loader
		d-i netcfg/wireless_security_type select wpa
		d-i netcfg/wireless_wpa string letmein1234

		# --------------------------------------------------- #

	EOF
}


rtd_oem_cfg_Account_Setup ()
{
	cat >> $1/$PRESEED <<-'EOF'

		# --------------------------------------------------- #
		# Account setup (temporary user account)
		# --------------------------------------------------- #
		# Setup an initial user and disable root login by default.
		# root login may be re-enabled later by setting a root password.
		# An encrypted password is set here, and should be changed
		# ASAP after the system is built. Preferebly connect to LDAP/AD
		# in a managed environment.
		# End of documentation
		d-i passwd/root-login boolean false
		d-i passwd/user-fullname string RTD User
		d-i passwd/username string tangarora
		d-i passwd/user-password seen true
		d-i user-setup/allow-password-weak boolean true
		d-i passwd/user-password-crypted password $6$Rn5/UTzjIs68MX$9gz8vmshGlPqse3VoX8dzSfhWxRVoYv1MB6aGRD8xdvztOf.gD.SxxVWkxYrwwbShB9Q14flquK/apbdQJ65t1
		d-i passwd/auto-login boolean true

		# --------------------------------------------------- #

	EOF
}


rtd_oem_preseed_cfg_Prevent_Install_On_USB ()
{
	cat >> $1/$PRESEED <<-'EOF'

		# --------------------------------------------------- #
		# Do NOT install on the USB stick(!)
		# --------------------------------------------------- #
		#
		# The Debian installer will install on the first disk it finds which can
		# sometimes be the USB stick itself. Work around this by rolling our own auto
		# detect logic which disallows installing on USB devices.
		#
		# d-i partman/early_command string [ "$(ls -A /tmp)" ] && umount -l /media || echo "Empty" ;
		# End of documentation
		d-i partman/early_command string \
			USBDEV=$(mount | grep hd-media | cut -d" " -f1 | sed "s/\(.*\)./\1/");\
			BOOTDEV=$(list-devices disk | grep -v \$USBDEV | head -1);\
			debconf-set partman-auto/disk $BOOTDEV;\
			debconf-set grub-installer/bootdev $BOOTDEV;

		# --------------------------------------------------- #

	EOF
}


rtd_oem_preseed_cfg_EFI ()
{
	cat >> $1/$PRESEED <<-'EOF'

		# --------------------------------------------------- #
		# EFI
		# --------------------------------------------------- #
		#
		# The EFI (Extensible Firmware Interface) system partition is a partition on a data storage device.
		# UEFI provides backward compatibility with legacy systems by reserving the first block (sector) of
		# the partition for compatibility code, effectively creating a legacy boot sector. On legacy BIOS-based
		# systems, the first sector of a partition is loaded into memory and execution is transferred to this code.
		# Here we tell setup to install EFI boot setup if possible so that both NEW and old systems may be handled
		# and the installed system can be started.
		d-i partman-efi/non_efi_system boolean true
		# End of documentation
		# --------------------------------------------------- #

	EOF
}

rtd_oem_preseed_cfg_Localization ()
{
	cat >> $1/$PRESEED <<-'EOF'

		# --------------------------------------------------- #
		# Localization
		# --------------------------------------------------- #
		# Provide localizaton preferences so that the prefferred
		# language is used for display and formats. Comparable to
		# the MUI in Microsoft environments.
		# End of documentation
		d-i debian-installer/locale string en_US.UTF-8
		d-i localechooser/supported-locales multiselect en_US.UTF-8, se_SE.UTF-8
		d-i console-setup/ask_detect boolean false

		# --------------------------------------------------- #



		# --------------------------------------------------- #
		# Set Keyboard layout
		# --------------------------------------------------- #
		# Set the prefferred keyboard layout. Keyboards will work
		# regardless, but the letters and symbols may not actually
		# be the ones drawn on the keys. Default is us.
		d-i keyboard-configuration/xkb-keymap select se
		d-i keyboard-configuration/layoutcode string se
		d-i debian-installer/keymap select se
		d-i keymap select se
		d-i console-setup/layoutcode string se
		d-i console-setup/ask_detect boolean false

		# --------------------------------------------------- #


		# --------------------------------------------------- #
		# Clock and time zone setup
		# --------------------------------------------------- #
		d-i clock-setup/utc boolean true
		d-i time/zone string Etc/UTC
		d-i clock-setup/ntp boolean true
		d-i clock-setup/ntp-server string ntp.ubuntu.com

		# --------------------------------------------------- #

		EOF
}

rtd_oem_preseed_cfg_GRUB_Bootloader_Installation ()
{
	cat >> $1/$PRESEED <<-'EOF'

		# --------------------------------------------------- #
		# GRUB bootloader installation
		# --------------------------------------------------- #
		#
		# Tell the grub-installer to install to the MBR even if it also finds some other
		# OS, which is more likely to allow the newly installed Linux OS to boot without issue.
		# End of documentation
		d-i grub-installer/only_debian boolean true
		d-i grub-installer/with_other_os boolean true
		# --------------------------------------------------- #

	EOF
}

rtd_oem_preseed_cfg_Disk_Layout ()
{
	cat >> $1/$PRESEED <<-'EOF'

		# --------------------------------------------------- #
		#   Disk layout (default encrypted disk)
		# --------------------------------------------------- #
		#
		# Set option to encrypt the hard disk:
		# By default the harddisk will be encrypted to pretect data
		# and will need to be unlocked with a password when the
		# system is booted. In addition a default is prefferred 
		# where the swap space is set to 200% of RAM so that 
		# hibernate can be supported. 
		# End of documentation

		d-i partman-auto/method string crypto
		d-i partman-crypto/passphrase password letmein1234
		d-i partman-crypto/passphrase-again password letmein1234
		d-i partman-auto-crypto/erase_disks boolean false
		d-i partman-lvm/device_remove_lvm boolean true
		d-i partman-lvm/device_remove_lvm_span boolean true
		d-i partman-auto/purge_lvm_from_device boolean true
		d-i partman-lvm/confirm boolean true
		d-i partman-lvm/confirm_nooverwrite boolean true
		d-i partman-auto-lvm/guided_size string max
		d-i partman-auto-lvm/new_vg_name string crypt
		d-i partman-auto/choose_recipe select root-encrypted
		d-i partman-auto/expert_recipe string                   \
		root-encrypted ::                                       \
			538 538 1075 free                               \
				$primary                                \
				$iflabel{ gpt }                         \
				$reusemethod{ }                         \
				method{ efi } format{ }                 \
			.                                               \
			500 500 500 ext3                                \
				$primary{ } $bootable{ }                \
				method{ format } format{ }              \
				use_filesystem{ } filesystem{ ext4 }    \
				mountpoint{ /boot }                     \
									\
			.                                               \
			200% 200% 200% linux-swap                       \
				$lvmok{ } lv_name{ swap }               \
				in_vg { crypt }                         \
				$primary{ }                             \
				method{ swap } format{ }                \
			.                                               \
			500 10000 1000000000 ext4                       \
				$lvmok{ } lv_name{ root }               \
				in_vg { crypt }                         \
				$primary{ }                             \
				method{ format } format{ }              \
				use_filesystem{ } filesystem{ ext4 }    \
				mountpoint{ / }                         \
			.                                               \
			2000 2000 2000 ext4                             \
				$primary{ }                             \
				method{ keep }                          \
				use_filesystem{ } filesystem{ ext4 }    \
				label{ rescuedisk }                     \
			.

		d-i partman-md/device_remove_md boolean true
		d-i partman-md/confirm boolean true
		d-i partman-basicfilesystems/no_mount_point boolean false
		d-i partman-partitioning/confirm_write_new_label boolean true
		d-i partman/choose_partition select finish
		d-i partman/confirm boolean true
		d-i partman/confirm_nooverwrite boolean true

		# --------------------------------------------------- #

	EOF
}

rtd_oem_preseed_cfg_Package_Selection ()
{
	cat >> $1/$PRESEED <<-EOF

		# --------------------------------------------------- #
		# Package selection
		# --------------------------------------------------- #
		# Packages may be selected as groups (meta packages) like kde-desktop or
		# as individual packages. Only one "pkgsel/include" string will be used though!
		# remembder to fit all the packages you want on one line.
		# tasksel tasksel/first multiselect standard options:
		# ubuntu-desktop-minimal kubuntu-desktop, ubuntu-gnome-desktop, lubuntu-desktop, ubuntu-mate-desktop
		# desktop,  gnome-desktop, kde-desktop, cinnamon-desktop, mate-desktop,
		# lxde-desktop, web-server, ssh-server, print-server.
		# The "OEM" line below ist to make it simple to replace the line with a
		# relevant chice of debian role using "sed" or similar.
		# End of documentation
		tasksel tasksel/first multiselect $2
		d-i pkgsel/include string splash openssh-server virt-what wget spice-vdagent

		# Valid choices for pkgsel/upgrade are: safe-upgrade full-upgrade none
		d-i pkgsel/upgrade select none
		d-i pkgsel/update-policy select unattended-upgrades

		# By default, the systemâ€™s locate database will be updated after the
		# installer has finished installing most packages. This may take a while, so
		# if you donâ€™t want it, you can set this to "false" to turn it off.
		# d-i pkgsel/updatedb boolean false
		# --------------------------------------------------- #
		
	EOF
}

rtd_oem_preseed_cfg_Addon_MinecraftServer()
{
	cat >> $1/$PRESEED <<-'EOF'

		# --------------------------------------------------- #
		# Addon Tasks for Minecraft Server
		# --------------------------------------------------- #
		# End of documentation
		d-i preseed/late_command string \
			in-target mkdir -p /etc/systemd/system/getty@tty1.service.d ; \
			in-target echo "***********  Updating Autologin information... ************ "; \
			in-target echo "[Service]" > /etc/systemd/system/getty@tty1.service.d/override.confv ; \
			in-target echo "ExecStart=" >> /etc/systemd/system/getty@tty1.service.d/override.conf ; \
			in-target echo "ExecStart=-/sbin/agetty --noissue --autologin tangarora "%I" "$TERM"" >> /etc/systemd/system/getty@tty1.service.d/override.conf ; \
			in-target echo "Type=idle" >> /etc/systemd/system/getty@tty1.service.d/override.conf ; \
			in-target echo "**********    Seting up minecraft.server to start automatically   ************* " ; \
			in-target echo "bash /home/tangarora/minecraft.server" >> /home/tangarora/.bashrc ; \
			in-target wget https://github.com/vonschutter/RTD-Minecraft-Server-Manager/raw/master/minecraft-server -O /home/tangarora/minecraft.server && chmod +x /home/tangarora/minecraft.server  ; \
			umount -l /media || echo "Empty"; \
			eject || true; \
			reboot; \
			echo "------  initial Setup Complete!  ------"

		# Answer the last question
		d-i debian-installer/splash boolean true

		# Option to try to greacefully eject the installation media:
		d-i cdrom-detect/eject boolean true

		# Shutdown machine
		d-i finish-install/reboot_in_progress note

		# --------------------------------------------------- #

	EOF
}

rtd_oem_preseed_cfg_Addon_Tasks ()
{
	cat >> $1/$PRESEED <<-'EOF'

		# --------------------------------------------------- #
		# Default preseed Addon Tasks 
		# --------------------------------------------------- #
		# End of documentation
		d-i preseed/late_command string \
			mkdir -p /target/opt/rtd/scripts; \
			mkdir -p /target/opt/rtd/log; \
			cp -r /task.sh /target/opt/rtd/scripts/; \
			cp /preseed.cfg /target/opt/rtd/log/; \
			in-target chmod +x /opt/rtd/scripts/task.sh; \
			in-target /bin/bash /opt/rtd/scripts/task.sh; \
			umount -l /media || echo "Empty"; \
			eject || true; \
			reboot; \
			echo "------  initial Setup Complete!  ------"

		# for ubuntu to work...
		ubiquity ubiquity/success_command string \
		 	mkdir -p /target/opt/rtd/scripts ;\
		 	mkdir -p /target/opt/rtd/log ;\
		 	cp -r /cdrom/task.sh /target/opt/rtd/scripts/ ;\
		 	cp /cdrom/preseed.cfg /target/opt/rtd/log/ ;\
		 	chmod +x /target/opt/rtd/scripts/task.sh ;\
		 	in-target /opt/rtd/scripts/task.sh ;\
			read -p "Press any key to continue...."

		# Answer the last question
		d-i debian-installer/splash boolean true

		# Option to try to greacefully eject the installation media:
		d-i cdrom-detect/eject boolean true

		# Shutdown machine
		d-i finish-install/reboot_in_progress note

		# --------------------------------------------------- #

	EOF
}










#                 __ 
#               .'  '. 
#              :      :
#              | _  _ |
#           .-.|(o)(o)|.-.        _._          _._
#          ( ( | .--. | ) )     .',_ '.      .' _,'.
#           '-/ (    ) \-'     / /' `\ \ __ / /' `\ \
#            /   '--'   \     / /     \.'  './     \ \
#            \ `"===="` /     `-`     : _  _ :      `-`
#             `\      /'              |(o)(o)|
#               `\  /'                |      |
#               /`-.-`\_             /        \
#         _..:;\._/V\_./:;.._       /   .--.   \
#       .'/;:;:;\ /^\ /:;:;:\'.     |  (    )  | 
#      / /;:;:;:;\| |/:;:;:;:\ \    _\  '--'  /__
#     / /;:;:;:;:;\_/:;:;:;:;:\ \ .'  '-.__.-'   `-.

#::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
#::::::::::::::                                          ::::::::::::::::::::::
#::::::::::::::          Script Internal Functions       ::::::::::::::::::::::
#::::::::::::::                                          ::::::::::::::::::::::
#::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::











oem_PowerShell_compatability ()
{
# Internal PowerShell compatability Library. 
# This is a collection of functions acting a simpified CMDlets. 
# The purpose of these internal libraries are to facilitate for scriptors that
# are familiar with the PowerShell scripting. 
# This should also profide simple and consistent way to do certain tasks that would
# need additional scripting. Currently there are these verb subject components:
# write_host (Write-Host), write_error (Write-Error), write_status (Write-Status), 
# write_warning (Write-Warning) and write_information (Write-Information)
# End of Documentation


	write_host () 
	{
	# write_host:
	# is a simplified and consistent way to write output to the screen.
	# This function will print a message to the standard out in GREEN.
	# Usage:
	# write_host String


		local echode="\033["
		case "$1" in
			--black  | -bk) color="${echode}0;30m";;
			--red    |  -r) color="${echode}1;31m";;
			--green  |  -g) color="${echode}1;32m";;
			--yellow |  -y) color="${echode}1;33m";;
			--blue   |  -b) color="${echode}1;34m";;
			--purple |  -p) color="${echode}1;35m";;
			--cyan   |  -c) color="${echode}1;36m";;
			--gray   | -gr) color="${echode}0;37m";;
			*) local text="$1"
		esac
		[[ -z "$text" ]] && local text="$color$2${echode}0m"
		echo "$text"
	}



	write_error () 
	{
	# write_error:
	# is a simplified and consistent way to write output to the screen.
	# write_error will print a message to the standard out in RED.
	# Usage:
	# write_error String


		local text=$1
		if [[ -n "$text" ]]; then
			echo -e "$red$text$endcolor"
		fi
	}


	write_warning ()  
	{
	# write_warning:
	# is a simplified and consistent way to write output to the screen.
	# write_warning will print a message to the standard out in Yellow.
	# Usage:
	# write_warning String


		local text=$1
		[ -n "$text" ] && echo -e "$yellow$text$endcolor"

	}


	write_status ()  
	{
	# write_status:
	# is a simplified and consistent way to write output to the screen.
	# write_status will print a message to the standard out in GREEN.
	# Usage:
	# write_status String


		local text=$1
		[ -n "$text" ] && echo -e "$green$text$endcolor"

	}


	write_information () 
	{
	# write_information:
	# is a simplified and consistent way to write output to the screen.
	# write_information will print a message to the standard out in BLUE.
	# Usage:
	# write_information String


		local text=$1
		[ -z "$text" ] && echo -e "$blue$text$endcolor"

	}
# End of Documentation
}





debug_list_loaded_internal_functions ()
{
# Function to list all functions loaded... for debugging purposes.
# End of documentation
	#|grep -v "write_"*
	i=1 
	for index in $(declare -F | awk '{print $NF}' | sort | egrep -v "^_" |grep -v "recipie_" |grep -v "debug_list"  )
	do
		echo "$index #$i "
		((i=i+1))

	done

}


debug_list_loaded_software_functions ()
{
# Function to list all functions loaded... for debugging purposes.
# End of documentation	
	i=1 
	for index in $(declare -F | awk '{print $NF}' | sort | egrep -v "^_" |grep "recipie_")
	do
		echo "$i $index "
		((i=i+1))

	done

}


set_colors
export RTDFUNCTIONS=1

if [ -z $1 ]; then
	echo OK
else 
	case $1 in 
		--help | -? )
			echo -e "${0##*/} :: RunTime Data Library HELP ::

			Usage: ${0##*/} [OPTIONS]
			valid option are :
			--help		 : Show this help text
			--list		 : List library functions (requires options: software, or internal, or all)
				software : (list) software install bundles available 
				internal : (list) internal functions loaded 
				all	 : (list) all library functions including software 
			--devhelp	 : diplay script developer's help 
			EXAMPLE: 
			${0##*/} --list --internal"
		;;
		--list )
			case $2 in 
				software ) debug_list_loaded_software_functions ;;
				internal ) debug_list_loaded_internal_functions ;;
				all ) ( echo -e $YELLOW "Software Recipies: $ENDCOLOR" && debug_list_loaded_software_functions && echo -e $YELLOW "INTERNAL Functions: $ENDCOLOR" && debug_list_loaded_internal_functions ) ;;
				* ) echo "USAGE: The --list option requires a (what option). Valid option are: software, internal, all." ;;
			esac
		;;
		--devhelp )
			while true; do
				exec 3>&1
				selection=$(dialog --clear --backtitle "${BRANDING:-" RunTime Data : Function library : Script Development Support"}" --title "RTD Library Loaded Functions:" --menu "\n Chose a function below to see more details about the function." "${HEIGHT:-25}" "${WIDTH:-110}" "${LIST_HEIGHT:-14}" $(debug_list_loaded_internal_functions) 2>&1 1>&3)
				exit_status=$?
				exec 3>&-

				case $exit_status in
					1) clear && echo [Cancel] && exit ;;
					255) clear && echo [ESC] && exit ;;
				esac

				case $selection in
					$selection )
						result=$(while IFS= read -r 'line'; do
							[[ "$line" == "$selection ()" ]]		&& printline="yes"
							[[ "$line" == "# End of documentation"* ]]	&& printline="no" 
							[[ "$line" == *"# End of documentation"* ]]	&& printline="no" 
							[[ "$line" == *End*of*Documentation* ]]		&& printline="no" 
							[[ "$printline" == "yes" ]]			&& echo "$line" |grep "# " |cut -c 2-
						done < $0 )
						dialog --clear --backtitle "${0##*/} :: RunTime Data Library HELP ::" --title "RTD Functon: $selection" --msgbox "$result" "${HEIGHT:-25}" "${WIDTH:-110}"
						return
					;;
					* ) exit ;;
				esac
			done
		;;
		* ) echo "No RECOGNIZED arguments provided: loading ${0:BASENAME}" ; echo "Use ${0:BASENAME} --help to see supported arguments"
		;;
	esac
fi
