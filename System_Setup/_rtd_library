#!/bin/bash
RTD_VERSION=2.0
<<Library_Documentation
::				R T D   F u n c t i o n   L i b r a r y
::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
::	Author(s):   	SLS, KLS, NB.  Buffalo Center, IA & Avarua, Cook Islands
:: 	Version:	2.0
::
::
::	Purpose:	To collect and enable the use of code snipplets in other scripts.
::			To document these thuroughly so that they may be usefull for learning BASH.
::     Usage: 		call this file using the "source" statment in bash.
::
::     This script is shared in the hopes that
::     someone will find it usefull.
::
::
::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

	Functions defined in this library:

	Function Name: 				Description:
	----------------------------------------------------------------------------------------------------------------
	check_dependencies			: Checks that software requirements are met so scripts do not fail
	debug_list_loaded_functions		: Lists all loaded RTD functions in the environment
	dl					: Downloads and installs a package from the internet (a bit insecure)
	enable_firewall				: Will turn on UFW and add the Allow SSH rule
	ensure_admin				: Elevates priveledges to admin "root" for the whole script (asks for password)
	InstallSoftwareFromRepo			: Installs a package from a repository (supports SUSE, Fedora, Cent OS, Ubuntu Deian etc.)
	is_software_package_available		: Checks to see if a software package is availabel in a repository (RPM and DEB)
	is_software_package_installed		: Checks to see if a software package allready is installed
	notice_rtd_loaded			: Notifies a script that RTD functions are loaded
	set_colors				: Set colors for prompting on screen in human usable variables: $RED, $GEEN etc.
	set_install_command			: Determines what install command should be used to install packages from repositories
	SofwareManagmentAvailabilityCHK		: Checks to see that the software managment system is not busy
	system_update				: Newer more universal software update function
	up2date					: Older universal software update function
	rtd_setup_choices_term_fallback		: For server setup, displays a menu where you may chose CLI productivity software (vim, alpine, byobu etc.).



Use Google Coding standards:
In general any function that is not both obvious and short must be commented. Any function in a library must be commented regardless of 
length or complexity. It should be possible for someone else to learn how to use your program or to use a function in your library 
by reading the comments (and self-help, if provided) without reading the code.

All function comments should describe the intended API behaviour using:

1	Description of the function.
2	Globals: List of global variables used and modified.
3	Arguments: Arguments taken.
4	Outputs: Output to STDOUT or STDERR.
5	Returns: Returned values other than the default exit status of the last command run.

Library_Documentation

###########################################################################
##                                                                       ##
##                         Settings                                      ##
##                                                                       ##
###########################################################################

source /opt/rtd/scripts/_rtd_recipies
source /opt/rtd/scripts/_branding

# Base folder structure for optional administrative commandlets and scripts:
_RTDSCR=$(if [ -f /opt/rtd/scripts ]; then echo /opt/rtd/scripts ; else ( mkdir -p /opt/rtd/scripts & echo  /opt/rtd/scripts ) ; fi )
_RTDCACHE=$(if [ -f /opt/rtd/cache ]; then echo /opt/rtd/cache ; else ( mkdir -p /opt/rtd/cache & echo  /opt/rtd/cache ) ; fi )
_RTDLOGSD=$(if [ -f /var/log/rtd ]; then echo /var/log/rtd ; else ( mkdir -p /var/log/rtd & echo  /var/log/rtd ) ; fi )

# Determine log file directory
_ERRLOGFILE=$_RTDLOGSD/$( basename $0)-error.log
_LOGFILE=$_RTDLOGSD/$( basename $0).log
_STATUSLOG=$_RTDLOGSD/$( basename $0)-status.log

###########################################################################
##                                                                       ##
##                         Functions                                     ##
##                                                                       ##
###########################################################################
#




set_colors () 
{
# Set colors for prompting on screen in human readable variables. These will be set globally
# and can be can be used by in echo statements to modify the color of the message.
# Examples:  $YELLOW, $RED, $ENDCOLOR (reset), $GREEN, $BLUE
# Usage: 
#	Simply call this function by stating its name:
# 	set_colors
# 	
# The function will not return any sucess or failure codes. It will do its best and exit.
# End of documentation

	YELLOW="\033[1;33m"
	RED="\033[1;31m"
	ENDCOLOR="\033[0m"
	GREEN="\033[1;32m"
	BLUE="\033[1;34m"

	color_dark0_hard="#1D2021"
	color_dark0="#282828"
	color_dark0_soft="#32302F"
	color_dark1="#3c3836"
	color_dark2="#504945"
	color_dark3="#665c54"
	color_dark4="#7C6F64"
	color_gray_245="#928374"
	color_gray_244="#928374"
	color_light0_hard="#FB4934"
	color_light0="#FBF1C7"
	color_light0_soft="#F2E5BC"
	color_light1="#EBDBB2"
	color_light2="#D5C4A1"
	color_light3="#BDAE93"
	color_light4="#A89984"
	color_bright_red="#FB4934"
	color_bright_green="#B8BB26"
	color_bright_yellow="#FABD2F"
	color_bright_blue="#83A598"
	color_bright_purple="#D3869B"
	color_bright_aqua="#8EC07C"
	color_bright_orange="#FE8019"
	color_neutral_red="#CC241D"
	color_neutral_green="#98971A"
	color_neutral_yellow="#D79921"
	color_neutral_blue="#458588"
	color_neutral_purple="#B16286"
	color_neutral_aqua="#689D6A"
	color_neutral_orange="#D65D0E"
	color_faded_red="#9D0006"
	color_faded_green="#79740E"
	color_faded_yellow="#B57614"
	color_faded_blue="#076678"
	color_faded_purple="#8F3F71"
	color_faded_aqua="#427B58"
	color_faded_orange="#AF3A03"

	music="
	╔══╗ ♫ \n
	║██║ ♪♪ \n
	║██║♫♪ \n
	║ ◎♫♪♫ \n
	╚══╝ Turn Up The Music!!! \n
	"

	picachu="
	⢀⣠⣾⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⠀⠀⠀⠀⣠⣤⣶⣶ \n
	⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⠀⠀⠀⢰⣿⣿⣿⣿ \n
	⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣧⣀⣀⣾⣿⣿⣿⣿ \n
	⣿⣿⣿⣿⣿⡏⠉⠛⢿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡿⣿ \n
	⣿⣿⣿⣿⣿⣿⠀⠀⠀⠈⠛⢿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⠿⠛⠉⠁⠀⣿ \n
	⣿⣿⣿⣿⣿⣿⣧⡀⠀⠀⠀⠀⠙⠿⠿⠿⠻⠿⠿⠟⠿⠛⠉⠀⠀⠀⠀⠀⣸⣿ \n
	⣿⣿⣿⣿⣿⣿⣿⣷⣄⠀⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣴⣿⣿ \n
	⣿⣿⣿⣿⣿⣿⣿⣿⣿⠏⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠠⣴⣿⣿⣿⣿ \n
	⣿⣿⣿⣿⣿⣿⣿⣿⡟⠀⠀⢰⣹⡆⠀⠀⠀⠀⠀⠀⣭⣷⠀⠀⠀⠸⣿⣿⣿⣿ \n
	⣿⣿⣿⣿⣿⣿⣿⣿⠃⠀⠀⠈⠉⠀⠀⠤⠄⠀⠀⠀⠉⠁⠀⠀⠀⠀⢿⣿⣿⣿ \n
	⣿⣿⣿⣿⣿⣿⣿⣿⢾⣿⣷⠀⠀⠀⠀⡠⠤⢄⠀⠀⠀⠠⣿⣿⣷⠀⢸⣿⣿⣿ \n
	⣿⣿⣿⣿⣿⣿⣿⣿⡀⠉⠀⠀⠀⠀⠀⢄⠀⢀⠀⠀⠀⠀⠉⠉⠁⠀⠀⣿⣿⣿ \n
	⣿⣿⣿⣿⣿⣿⣿⣿⣧⠀⠀⠀⠀⠀⠀⠀⠈⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢹⣿⣿ \n
	⣿⣿⣿⣿⣿⣿⣿⣿⣿⠃⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⣿⣿ \n
	"
	chess="♟️ ♔ ♕ ♖ ♗ ♘ ♙ ♚ ♛ ♜ ♝ ♞ ♟"
	colorcircle="🔴 🟠 🟡 🟢 🔵 🟣 🟤"
	colorsquares=" 🟥 🟧 🟨 🟩 🟦 🟪 🟫"
}




ensure_admin () 
{
# Function to ensure administrative privileges such that system wide settings
# or configuration may be done. This function will make the script call itself
# with sudo if the user ID is not 0 e.g. root.
# End of documentation
	if ! "$UID" -eq 0 ; then
		echo -e $YELLOW "This script needs administrative access..." $ENDCOLOR
		sudo bash "$0" "$*"
		exit 4
	fi
}




rtd_oem_kde_set_wallpaper()
{
# rtd_oem_kde_set_wallpaper
# Function to set KDE Plasma wallpaper from a script. this function expects one variable 
# indication what file to set as background. You must provide the full path to the file. 
# rtd_oem_kde_set_wallpaper /opt/oem/wallpaper.png Supported fule types are: 
# webm, mp4, png, jpeg, gif, webp. 
# End of documentation

	echo "Setting wallpaper $1" 
	full_image_path=$(realpath "$1")
	ext=$(file -b --mime-type "$full_image_path")

	if [ -z "$2" ]; then
	# Identify filetype and make changes
	case $(echo $ext | cut -d'/' -f2) in
		"mp4"|"webm") type='VideoWallpaper' ; write='VideoWallpaperBackgroundVideo';;
		"png"|"jpeg") type='org.kde.image' ; write='Image' ;;
		"gif"|"webp") type='GifWallpaper' ; write="GifWallpaperBackgroundGif" ;;
	esac
	else
	type="$2";
	write="$3";
	fi

	wallpaper_set_script="var allDesktops = desktops();
	print (allDesktops);
	for (i=0;i<allDesktops.length;i++)
	{
		d = allDesktops[i];
		d.wallpaperPlugin = '${type}';
		d.currentConfigGroup = Array('Wallpaper', '${type}', 'General');
		d.writeConfig('Image', 'file:///dev/null')
		d.writeConfig('$write', 'file://${full_image_path}')
	}"

	qdbus org.kde.plasmashell /PlasmaShell org.kde.PlasmaShell.evaluateScript "${wallpaper_set_script}"
	kwriteconfig5 --file kscreenlockerrc --group Greeter --group Wallpaper --group org.kde.image --group General --key Image "file://$full_image_path"
}




rtd_oem_remove_non_western_latin_fonts () 
{
# rtd_oem_remove_non_western_latin_fonts: a simple function to remove known
# non-western (latin) fonts from a distribution. Notably, Ubuntu provides too many fonts
# of all kinds by default, even if the user will never need the fonts. However, the fonts
# may cause unexpected font tool behavior and crashes, due to the large number of fonts 
# and their features. It is there fore a good Idea to remove these fonts if they are not needed.
# Usage: 
#	Simply call this function by stating its name:
# 	rtd_oem_remove_non_western_latin_fonts
# 	
# The function will not return any sucess or failure codes. It will do its best and exit.
# End of documentation

	font_list="fonts-kacst fonts-kacst-one fonts-khmeros-core fonts-lklug-sinhala fonts-lohit-guru fonts-guru fonts-nanum fonts-noto-cjk fonts-takao-pgothic fonts-tibetan-machine fonts-guru-extra \
		fonts-lao fonts-sil-padauk fonts-sil-abyssinica fonts-tlwg-* fonts-beng fonts-beng-extra fonts-deva fonts-deva-extra fonts-gubbi fonts-gujr fonts-gujr-extra fonts-kalapi fonts-knda \
		fonts-lohit-* fonts-noto-* fonts-orya* fonts-pagul fonts-sahadeva fonts-samyak-* fonts-sarai fonts-smc fonts-smc-* fonts-taml fonts-telu fonts-telu-extra"
	echo "Attempting to remove non-western fonts..."
	count=0
	for i in $font_list ; do 
		rtd_oem_remove_software $i &>/dev/null && (( count++))
	done
	echo "Removed [ $count ] non-western Fonts"
}



rtd_oem_remove_software () 
{
# rtd_oem_remove_software
# The OEM remove software function will attempt to remove whatever package name given
# as an argument using whatever package system found on the system. This is provided 
# for portability and convenience. Currently, this functions will attempt to use
# pkcon (prefferred as it run on many distributions), apt, yum, dnf, and zypper. 
# Additional package manager may be added as time allows. 
# Usage: 
# 	call this function using one argument only for reliability reasons; 
#	as per the below example. If thre is a need to remove a large number of
#	packages it is reccommended to use a for loop and call this function, 
#	still realizing the benefit of mylti-distribution support.
#
#	rtd_oem_remove_software packagename
#
# If a failure occurs this function will return a non "0" exit code. (1)
# End of documentation

	if [[ $(echo $OSTYPE |grep "linux") ]]; then
		echo "Trying to remove package $*"
		if hash dnf 2>/dev/null; then
			dnf -y remove $*
			return $?
		elif hash yum 2>/dev/null; then
			yum -y remove $*
			return $?
		elif hash zypper 2>/dev/null; then
			zypper -y remove $*
			return $?
		elif hash apt 2>/dev/null; then
			apt-get -y remove $* && apt -y autoremove
			return $?
		elif hash pkcon 2>/dev/null; then
			pkcon remove $* -y --autoremove
			return $?
		else
			echo -e $YELLOW "This system does not seem to have a software managment system" $ENDCOLOR
			return 1
		fi
	elif [[ "$OSTYPE" == "freebsd"* ]]; then
		echo "Free BSD is currently unsupported... "
		return 1
	else
		echo "Though you can run bash, I have no Idea how to remove software here!"
		return 1
	fi
}


set_install_command () 
{
# set_install_command
# add global install command for portability and convenience
# If you need to use this script in an rpm based system you could modify the install
# command here to suit dnf, yum, zypper... By default packages of patternd that do not
# match should be skipped. Use "export option" so child processes also see the variiables.
# End of documentation
	if [[ 'echo $OSTYPE" |grep "linux"' ]]; then
		if hash pkcon 2>/dev/null; then
			# If package kit is available then prefer this
			echo -e $YELLOW "Setting install options for Package Kit" $ENDCOLOR
			export _INSTCMD="pkcon -y  install"
		elif hash yum 2>/dev/null; then
			# If package kit is not available try yum (RedHat, Cent OS, Fedora)
			echo -e $YELLOW "Setting install options for YUM" $ENDCOLOR
			export _INSTCMD="yum -y  install"
		elif hash apt 2>/dev/null; then
			# If package kit is not available try apt (Debian, Ubuntu, and all derivatives)
			echo -e $YELLOW "Setting install options for DEB" $ENDCOLOR
			export _INSTCMD="apt-get -y -qq --allow-change-held-packages --ignore-missing install"
			export DEBIAN_FRONTEND=noninteractive
		elif hash zypper 2>/dev/null; then
			# If package kit is not available try zypper (Open SUSE)
			echo -e $YELLOW "Setting install options for ZYPPER" $ENDCOLOR
			export _INSTCMD="zypper install -y "
		else
			echo -e $YELLOW "This system does not seem to have a software managment system" $ENDCOLOR
			exit 1
		fi

	elif [[ "$OSTYPE" == "freebsd"* ]]; then
		echo "Free BSD is currently unsupported... "
		export _INSTCMD="echo I dont know how to install suff on FreeBSD!"
	else
	echo "I have no Idea what this system is"
		export _INSTCMD="Whatever!"
		exit 1
	fi
}



enable_firewall () 
{
# enable_firewall
# Function to enable system firewall and add a given rule. This simple function
# enables Uncomplicated Fire Wall (UFW) and adds a rule to allow SSH to
# pass.
# End of documentation
	if hash ufw 2>/dev/null; then
			echo -e $YELLOW "Configure Firewall:" $ENDCOLOR
			ufw enable && ufw allow ssh
	else
			echo -e $faded_orange "UFW not present on this system: please turn on the firewall and configure it manually!" $ENDCOLOR
	fi
}




add_software_task ()
{
# Display executed task and echo ON/NOK based on sucess
# This function is created to reduce the terminal output and create a more poliches output of
# the tasks executed. This function has no idea shat it is doing, it will simply call the function 
# it was asked to call or execute the command ist was asked to, and echo OK or FAIL based on the 
# return code. 
# End of documentation
	PAD="------------------------------------------"
	LINE=$(printf "%s %s" "$@" "$PAD" | cut -c 1-${#PAD})
	echo -ne "Installing "$LINE"":""\ & $@ &>/dev/null && printf "%b%-6s%b [ \xE2\x9C\x94 ] $GREEN OK!$ENDCOLOR   \n" ||printf "%b%-6s%b [ ! ] $RED FAILED $ENDCOLOR  \n"
}




dl ()
{
# Function to ease and make consistent the downloading of the non repository packages and
# install them. It can install any package that Package Kit can manage (available on most Linux dists)
# It expects one parameter: the complete URL to download from.
# End of documentation

	download_url="$1"
	echo "$1"
	fetch_file () { 
		wget -P /opt/rtd/cache $download_url 1>>$_LOGFILE 2>>$_ERRLOGFILE 
	}

	echo  "    - getting package $download_url ..."
	if hash wget >/dev/null ; then
		fetch_file
	else
		check_dependencies wget
		fetch_file
	fi

	echo "    - Installing package: $(basename $download_url)..."
	if hash pkcon >/dev/null ; then
		pkcon install-local -y /opt/rtd/cache/$(basename $download_url) 1>>$_LOGFILE 2>>$_ERRLOGFILE
	else 
		check_dependencies packagekit-tools
		pkcon install-local -y /opt/rtd/cache/$(basename $download_url) 1>>$_LOGFILE 2>>$_ERRLOGFILE
	fi
}





SofwareManagmentAvailabilityCHK ()
{
# Function to check and see if the system software managment is available. In some cases
# the sofware managment system may be in use. Should this be the case, this function will
# wait undill the system is free for use.
# TODO: Add support for fedora, Centos, SuSE.
# End of documentation
	echo ""
	echo -e $YELLOW"--- Checking if software maintenance system is available:" $ENDCOLOR
	i=0
	tput sc
	while fuser /var/lib/dpkg/lock >/dev/null 2>&1 ; do
		case $(($i % 4)) in
			0 ) j="-" ;;
			1 ) j="\\" ;;
			2 ) j="|" ;;
			3 ) j="/" ;;
		esac    
		tput rc
		echo -en "\r[$j] Waiting for other software managers to finish..."\


		sleep 5
		((i=i+1))
	done
}




rtd_oem_reset_default_environment_config ()
{
# Function to reset temporary configurations to their original setings from the
# distributor. To configure and/or automatically install Linux systems RTD OEM
# load process must make some changes to the system in question that are not
# good security practice or that may be disruptive during normal operations.
# These setings are not limited to bu include "auto login", "auto sudo" and
# "auto running scripts"...
# End of documentation

	# Disable the automatically trying to install OEM software
	[[ -f /etc/xdg/autostart/org.runtimedata.oem.cofig.desktop ]] && mv /etc/xdg/autostart/org.runtimedata.oem.cofig.desktop /opt/rtd/scripts
	[[ -f /etc/sudoers.d/99_sudo_include_file ]] && mv /etc/sudoers.d/99_sudo_include_file /opt/rtd/scripts
	cp /home/$SUDO_USER/.bashrc /opt/rtd/scripts
	sed -i '/xhost\ local:root/d' /home/$SUDO_USER/.bashrc
}




rtd_wait_for_internet_availability () 
{
# Function that, when called, will wait for an active internet connection
# to be available before before continuing. Most softwrare install activities
# need an active internet connection to be able to install and update software.
# Naturally, some in house loads use local mirrors, but if you can see the
# internet, you would have access to your own ropositories as well...
# End of documentation



	echo "Waiting for internet access..."
	echo "NOTE: Free access to the internet is required to continue."
	while ! ping -c 1 -W 1 8.8.8.8 &>/dev/null ; do
		echo Waiting...
		sleep 5
	done
}





 up2date ()
{
# Function to simplify updating system completely. At present this function sets the
# highest preference to use "pkcon", the command line interface of "Package Kit" since
# this is the most consistent across different distrbutions. It may even work on BSD.
# Only if "pkcon" is not available, will the function use the identified distro native
# software manager: apt, yum, zypper etc. This is to maintain stability since a distro may
# alias another distributions command (like SuSE does with apt) to be helpfull.
# This is one of the first update functions written and is kept for compatibility.
# End of documentation
	echo -e $YELLOW"--- Running up2date function:" $ENDCOLOR

	if hash pkcon 2>/dev/null; then
		pkcon update -y 		1>>$_LOGFILE 2>>$_ERRLOGFILE
	elif hash yum 2>/dev/null; then
		yum update -y 			1>>$_LOGFILE 2>>$_ERRLOGFILE
	elif hash apt 2>/dev/null; then
		apt-get update 			1>>$_LOGFILE 2>>$_ERRLOGFILE
		apt-get upgrade -y 		1>>$_LOGFILE 2>>$_ERRLOGFILE
		apt-get autoremove -y 		1>>$_LOGFILE 2>>$_ERRLOGFILE
	elif hash zypper 2>/dev/null; then
		return zypper up -y		1>>$_LOGFILE 2>>$_ERRLOGFILE
	else
		return 3
	fi
}






is_software_package_installed ()
{
# Function to check if a piece of software is installed. This function will first check
# if the package manager is deb, zypper or rpm, and then take one parameter passed
# and evauate if a software package by that name is installed. This function
# will return a "0" or "1" return based on the package managers return code.
# Call this function by:
# is_software_package_installed "package name"
#                 or
# is_software_package_installed "$1" if calling this function from a script
# or another function receiving a parameter.
#
# End of documentation

	if hash yum 2>/dev/null; then
		rpm -q "$1" > /dev/null 2>&1 && return 0 || return 1
	elif hash apt 2>/dev/null; then
		dpkg -l "$1" 2>/dev/null |tail -1 |grep "ii  $1" > /dev/null 2>&1 && return 0 || return 1
	elif hash zypper 2>/dev/null; then
		zypper se "$1" > /dev/null 2>&1 && return 0 || return 1
	else
		return 3
	fi
}





is_software_package_available ()
{
# Function to chek if a package is available in whetever repository, and
# if there return a "0" and if not return a "1" or a "3" if there is no recognizable
# package manager found. the function expects the name of the package
# to be a parameter passed to this fuction. Call this function by:
# is_software_package_available "package name"
#                 or
# is_software_package_available "$1" if calling this function from a script
# or another function receiving a parameter.
#
# Supported base distributions: Fedora . SuSE . Debian
# End of documentation

	if hash yum 2>/dev/null; then
		yum list available "$1" &> /dev/null && return 0 || return 1
	elif hash apt 2>/dev/null; then
		apt -qq list "$1" 2>/dev/null | grep -q "$1" && return 0 || return 1
	elif hash zypper 2>/dev/null; then
		return zypper info "$1" &> /dev/null && return 0 || return 1
	else
		return 3
	fi

}





InstallSoftwareFromRepo ()
{
# Function to simplify the installation of software by including all display and
# installation logic for a given software provider. This should be expanded to include flatpack
# snap for example. It should be the same consistent way no matter flavor of Linux.
# This function uses the "$_INSTCMD" to install software. "$_INSTCMD" is defined separatley
# in the "set_install_command" function (a dependency to this function) and could
# be an RPM or deb string, or even snap or flatpack. A preference order between package system and
# snap or flatpack use.
# End of documentation

	# Ask function how to install software... 
	set_install_command >>/dev/null 2>&1

	# make some decent display terminal Graphics...
	PAD="------------------------------------------------"
	LINE=$(printf "%s %s" "$@" "$PAD" | cut -c 1-${#PAD})
	PRE=" - Installing $LINE :"
	# Test if package name is installed, if not then...
	if ! is_software_package_installed "$1"; then
		if is_software_package_available "$1"; then
			echo -ne "$PRE"\ & $_INSTCMD "$1" 1>>$_LOGFILE 2>>$_ERRLOGFILE && printf "%b%-6s%b [ \xE2\x9C\x94 ] $GREEN OK!$ENDCOLOR \n" ||printf "%b%-6s%b [ ! ] $RED FAILED $ENDCOLOR \n"
			if [ $? != 0 ];
			then
				return 1 & exit 1
			fi
		else
			echo -ne "$PRE"\ && printf "%b%-6s%b [ \xE2\x9C\x94 ] $YELLOW NOT AVAILABLE... $ENDCOLOR \n"
		fi
	else
		echo -ne "$PRE"\ && printf "%b%-6s%b [ \xE2\x9C\x94 ] $YELLOW Allready Installed... $ENDCOLOR \n"
	fi
: --
}





check_dependencies () 
{
# Function to check that a piece of software is installed and if not install it.
# Works for apt based systems currently. The function will take a parameter that is expected to
# match the softwre command line name or rather the name of the package. This should get
# updated to also check and install from snap and flatpack.
# End of documentation

	#---------------------------------------------------------------
	echo "Checking for script dependencies and install if not there..."
	#---------------------------------------------------------------
	    if is_software_package_installed $1 ; then
		echo -e $GREEN"I found that $1 is present on this system... thankyou for that! " $ENDCOLOR
	    else
		echo -e $YELLOW"You seem to have no $1... I will try to get it... " $ENDCOLOR
		InstallSoftwareFromRepo $1
		    if [ $? != 0 ];
		    then
			echo -e $RED "That install didn't work out so well."
			echo -e "Please manually try to add the software since I couldn't do it." $ENDCOLOR
			exit
		    fi
		echo "OK Done! Continuing..."
	    fi
}





system_update () 
{
# Function to update the Linux based system. This function is universal for all
# distributions that have package kit available. It works in the same manner on
# RedHat/Fedora, Debian/Ubuntu and all their derivatives. When invoked as a
# part in a script, it is wist to ensure that the package kit is available
# by using the "check_dependencies" function to ensure that the software is available.
# End of documentation

    if hash pkcon 2>/dev/null; then
    	pkcon refresh
	pkcon update -y
    else
	echo "You seem to have now Package Kit... I will try to get it... "
	echo "I will need to become admin to do that..."
	sudo check_dependencies packagekit
	    if [ $? != 0 ];
	    then
		echo "That install didn't work out so well."
		echo "Defaulting to the onld Up2Date Function"
		up2date
	    fi
	echo "OK trying again!"
    	pkcon refresh
	pkcon update -y
    fi
}




rtd_setup_choices_term_fallback () 
{
# Function to display legacy installation options. This will install software that is usefull
# on a really old system, or a remote system only accessible via SSH. This may be a good
# usecase if oyu happen to be in an opressed geographic locaiton where your only option is
# to ssh to a remote server and access email and web that way. Perfomance in these cases
# may be very poor over the internet (as for example with the great firewall of China). In
# Such a case it would be usefull to have the good old CLI software! :)
# End of documentation

	# List Options to be available for choice in the RTD System Configurator...
	cmd=(dialog --backtitle "RTD OEM System Builder Configuraton Menu" --title "Terminal Software Options Menu" --separate-output --checklist "We did not find a graphical interface. No matter, you can be productive in the cli environment. Please Select Software and Configuration below:" 22 85 16 )
	options=(1 "Base RTD OEM Software" on
		 2 "Alpine email client" on
		 3 "Vim text editor" on
		 4 "Finch multi protocol chat" on
		 5 "Word Grinder word precessor" on
		 6 "Spreadsheet Calculator" on
		 7 "TPP Presentation Program" on
		 8 "Midnight Commander file manager (Norton Commander)" on
		 9 "Cmus Music Player" on
		 10 "Byobu Terminal Window Manger" on
		 11 "W3M web Browser" on
		 12 "LYNX Web Browser" on
		 13 "Mega.nz command line tools (Mega-CMD)" on
		 14 "Rtorrent torrent download software" off
		 15 "Install the OpenVpn client Software" on
		 16 "Games: Freesweep mine sweep game" on
		 17 "Games: Bastet Tetris Game" on
		 18 "OEM Customizatons" on
		)

			choices=$("${cmd[@]}" "${options[@]}" 2>&1 >/dev/tty)
			clear
			for choice in $choices
			do
			    case $choice in
				1) for i in netstat nmcli htop powertop iftop monit nethogs bmon darkstat ss mtr glances nmap iostat multitail ncdu multitail ; do InstallSoftwareFromRepo $i ; done ;;
				2)  InstallSoftwareFromRepo alpine ;;
				3)  InstallSoftwareFromRepo vim ;;
				4)  InstallSoftwareFromRepo finch ;;
				5)  InstallSoftwareFromRepo wordgrinder ;;
				6)  InstallSoftwareFromRepo sc ;;
				7)  InstallSoftwareFromRepo tpp ;;
				8)  InstallSoftwareFromRepo mc ;;
				9)  InstallSoftwareFromRepo cmus ;;
				10) InstallSoftwareFromRepo byobu ;;
				11) InstallSoftwareFromRepo w3m ;;
				12) InstallSoftwareFromRepo lynx ;;
				13) dl https://mega.nz/linux/MEGAsync/xUbuntu_19.04/amd64/megacmd-*.deb	;;
				14) InstallSoftwareFromRepo rtorrent ;;
				15) InstallSoftwareFromRepo openvpn ;;
				16) InstallSoftwareFromRepo freesweep ;;
				17) InstallSoftwareFromRepo bastet ;;
				18) recipie_OEM_config ;;
			esac
		done
}





debug_list_loaded_internal_functions ()
{
# Function to list all functions loaded... for debugging purposes.
# End of documentation
	i=1 
	for index in $(declare -F | awk '{print $NF}' | sort | egrep -v "^_" |grep -v "recipie_" |grep -v "debug_list")
	do
		#echo "$i $index "
		echo "$index #$i "
		((i=i+1))

	done

}


debug_list_loaded_software_functions ()
{
# Function to list all functions loaded... for debugging purposes.
# End of documentation	
	i=1 
	for index in $(declare -F | awk '{print $NF}' | sort | egrep -v "^_" |grep "recipie_")
	do
		echo "$i $index "
		((i=i+1))

	done

}


set_colors
export RTDFUNCTIONS=1

if [ -z $1 ]; then
	echo OK
else 
	case $1 in 
		--help | -? )
			echo -e "${0##*/} :: RunTime Data Library HELP ::

			Usage: ${0##*/} [OPTIONS]
			valid option are :
			--help		 : Show this help text
			--list		 : List library functions (requires options: software, or internal, or all)
				software : (list) software install bundles available 
				internal : (list) internal functions loaded 
				all	 : (list) all library functions including software 
			--devhelp	 : diplay script developer's help 
			EXAMPLE: 
			${0##*/} --list --internal"
		;;
		--list )
			case $2 in 
				software ) debug_list_loaded_software_functions ;;
				internal ) debug_list_loaded_internal_functions ;;
				all ) ( echo -e $YELLOW "Software Recipies: $ENDCOLOR" && debug_list_loaded_software_functions && echo -e $YELLOW "INTERNAL Functions: $ENDCOLOR" && debug_list_loaded_internal_functions ) ;;
				* ) echo "USAGE: The --list option requires a (what option). Valid option are: software, internal, all." ;;
			esac
		;;
		--devhelp )
			while true; do
				exec 3>&1
				selection=$(dialog --clear --backtitle "${BRANDING:-" RunTime Data : Function library : Script Development Support"}" --title "RTD Library Loaded Functions:" --menu "\n Chose a function below to see more details about the function." "${HEIGHT:-25}" "${WIDTH:-110}" "${LIST_HEIGHT:-14}" $(debug_list_loaded_internal_functions) 2>&1 1>&3)
				exit_status=$?
				exec 3>&-

				case $exit_status in
					1) clear && echo [Cancel] && exit ;;
					255) clear && echo [ESC] && exit ;;
				esac

				case $selection in
					$selection )
						result=$(while IFS= read -r line; do
							[[ $line == $selection* ]]			&& printline="yes"
							[[ $printline == "yes" ]]			&& echo "$line" |grep "# " |cut -c 2-
							[[ $line == *\#" End of documentation"* ]]	&& printline="no"
						done < $0 )
						dialog --clear --backtitle "${0##*/} :: RunTime Data Library HELP ::" --title "RTD Functon: $selection" --msgbox "$result" "${HEIGHT:-25}" "${WIDTH:-110}"
						return
					;;
					* ) exit ;;
				esac
			done
		;;
		* ) echo "No RECOGNIZED arguments provided: loading ${0:BASENAME}" ; echo "Use ${0:BASENAME} --help to see supported arguments"
		;;
	esac
fi
