#!/bin/bash
#
#::             Linux deb and rpm based distro functions that may be usefull for admin 
#::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
#::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
#:: Author:   	Stephan S. & Nate B. Buffalo Center, IA
#:: Version 1.01
#::
#::
#::	Purpose: to collect and enable the use of code snipplets in other scripts. 
#::     Usage: call this file using the "source" statment in bash.
#:: 
#::     This script is shared in the hopes that
#::     someone will find it usefull.
#::
#::
#::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
#::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

###########################################################################
##                                                                       ##
##                         Functions                                     ##
##                                                                       ##
###########################################################################
#





# Set colors for prompting on screen in human readable variables. These will be set globally
# and can be can be used by in echo statements to modify the color of the message. 
# Examples:  $YELLOW, $RED, $ENDCOLOR (reset), $GREEN, $BLUE
function set_colors () {
	YELLOW="\033[1;33m"
	RED="\033[0;31m"
	ENDCOLOR="\033[0m"
	GREEN="\033[0;32m"
	BLUE="\033[0;34m"
}





# Function to ensure administrative privileges such that system wide settings 
# or configuration may be done. This function will make the script call itself 
# with sudo if the user ID is not 0 e.g. root.
function ensure_admin () {
	[ "$UID" -eq 0 ] || echo -e $YELLOW "This script needs administrative access..." $ENDCOLOR
	[ "$UID" -eq 0 ] || exec sudo bash "$0" "$@"
}






function set_install_command () {
	# add global install command for portability and convenience
	# If you need to use this script in an rpm based system you could modify the install
	# command here to suit dnf, yum, zypper... By default packages of patternd that do not
	# match should be skipped. Use "export option" so child processes also see the variiables.
        if [[ "$OSTYPE" == "linux-gnu" ]]; then
	        if hash yum 2>/dev/null; then
		        echo -e $YELLOW "Setting install options for YUM" $ENDCOLOR
		        export _INSTCMD="yum install -y "
	        elif hash apt 2>/dev/null; then
		        echo -e $YELLOW "Setting install options for DEB" $ENDCOLOR	        
		        # tell debian based installers (Ubuntu, Mint etc.) to be quiet.
	                export _INSTCMD="apt-get -y -qq --allow-change-held-packages --ignore-missing install"
	                export DEBIAN_FRONTEND=noninteractive
	                # Enable all repositories while disabling source repository list downloads in sources.list
	                sed -i -e "s/# deb http/deb http/g" /etc/apt/sources.list
	                sed -i -e "s/deb-src/# deb-src/g" /etc/apt/sources.list
	        elif hash zypper 2>/dev/null; then
	                echo -e $YELLOW "Setting install options for ZYPPER" $ENDCOLOR
		        export _INSTCMD="zypper install -y "
		else
		        echo -e $YELLOW "This system does not seem to have a software managment system" $ENDCOLOR
	        fi

        elif [[ "$OSTYPE" == "freebsd"* ]]; then
                echo "Free BSD is currently unsupported... "
                export _INSTCMD="echo I dont know how to install suff on FreeBSD!"
        else
               echo "I have no Idea what this system is"
                export _INSTCMD="echo Whatever!"
        fi
}






# Function to enable system firewall and add a given rule. 
function enable_firewall () {
	# Enable firewall in Ubuntu systems
	if hash ufw 2>/dev/null; then
			echo -e $YELLOW "Configure Firewall:" $ENDCOLOR
			ufw enable && ufw allow ssh
	else
			echo UFW not present on this system...
	fi
}





# Function to ease and make consistent the downloading of the non repository packages and
# install them. This function presently only works with apt. This should be expanded to include
# RPM packages as well. 
# First parameter is the URL, second is the name of the deb, to bypass version
# naming issues, use wildcards like skype*.deb
function dl ()
{
	if [ -z "$_ERRLOGFILE" ]; then $_ERRLOGFILE=$0.log ; else echo "Logfile is set to: '$_ERRLOGFILE'"; fi
	if [ -z "$_LOGFILE" ]; then $_LOGFILE=$0.log ; else echo "Logfile is set to: '$_LOGFILE'"; fi
	echo  "   - geting package $2 ..."
	wget -P /var/apt/cache/archives/ $1 1>>$_LOGFILE 2>>$_ERRLOGFILE
	echo "    - Installing package $2 ..."
	dpkg -i /var/apt/cache/archives/$2 1>>$_LOGFILE 2>>$_ERRLOGFILE
	echo "    - Installing dependencies for $2..."
	apt-get -f install -y -qq --allow-change-held-packages 1>>$_LOGFILE 2>>$_ERRLOGFILE
}





# Function to check and see if the system software managment is available. In some cases 
# the sofware managment system may be in use. Should this be the case, this function will
# wait undill the system is free for use. 
function SofwareManagmentAvailabilityCHK ()
{
        echo -e $YELLOW"--- Checking if software maintenance system is available:" $ENDCOLOR
        i=0
        tput sc
        while fuser /var/lib/dpkg/lock >/dev/null 2>&1 ; do
            case $(($i % 4)) in
                0 ) j="-" ;;
                1 ) j="\\" ;;
                2 ) j="|" ;;
                3 ) j="/" ;;
            esac
            tput rc
            echo -en "\r[$j] Waiting for other software managers to finish..."
            echo " "
            sleep 0.5
            ((i=i+1))
        done

        # Deprecated code below:
        # while [ -f /var/lib/dpkg/lock ] ;
        #		do
        #			echo The software managment system is locked...
        #			echo Waiting 10 seconds for software managment system to be ready:
        #			for i in {0..10}; do echo -ne "$i"'\r'; sleep 1; done; echo
        #			echo force unlocking package managment...
        #			rm -f  /var/lib/apt/lists/lock
        #			rm -f /var/lib/dpkg/lock
        #	done
}





# Function to simplify updating system completely. At present this function simply 
# uses apt but should be modified to update RPM if that is used on the system. 
function up2date ()
{
        if hash yum 2>/dev/null; then
	        # Ensure that the expected variables are defined.
	        if [ -z "$_ERRLOGFILE" ]; then $_ERRLOGFILE=$0.log ; else echo "     Logfile is set to: '$_ERRLOGFILE'"; fi
	        if [ -z "$_LOGFILE" ]; then $_LOGFILE=$0.log ; else echo "     Logfile is set to: '$_LOGFILE'"; fi
	        yum update -y 1>>$_LOGFILE 2>>$_ERRLOGFILE 
        elif hash apt 2>/dev/null; then
	        # Ensure that the expected variables are defined.
	        if [ -z "$_ERRLOGFILE" ]; then $_ERRLOGFILE=$0.log ; else echo "     Logfile is set to: '$_ERRLOGFILE'"; fi
	        if [ -z "$_LOGFILE" ]; then $_LOGFILE=$0.log ; else echo "     Logfile is set to: '$_LOGFILE'"; fi
		/opt/rtd/scripts/rtd-update-ubuntu
	        #echo -e $YELLOW"--- Running up2date function:" $ENDCOLOR
	        #echo "--- Refreshing Software repositories; this may take a minute..."
	        #apt-get update 1>>$_LOGFILE 2>>$_ERRLOGFILE
	        #echo "--- Installing System Updates; this may take a minute..."
	        #apt-get dist-upgrade -y -qq --allow-change-held-packages --ignore-missing 1>>$_LOGFILE 2>>$_ERRLOGFILE
	        #echo "--- Cleaning up unused software; this may take a minute..."
	        #apt-get autoremove -y 1>>$_LOGFILE 2>>$_ERRLOGFILE 
        elif hash zypper 2>/dev/null; then
        	# Ensure that the expected variables are defined.
	        if [ -z "$_ERRLOGFILE" ]; then $_ERRLOGFILE=$0.log ; else echo "     Logfile is set to: '$_ERRLOGFILE'"; fi
	        if [ -z "$_LOGFILE" ]; then $_LOGFILE=$0.log ; else echo "     Logfile is set to: '$_LOGFILE'"; fi
                return zypper up 1>>$_LOGFILE 2>>$_ERRLOGFILE 
	else
	        return 3
        fi
}





# Function to check if a piece of software is installed. This function will first check
# if the package manager is deb, zypper or rpm, and then take one parameter passed
# and evauate if a software package by that name is installed. This function
# will return a "0" or "1" return based on the package managers return code.
# Call this function by: 
# is_software_package_installed "package name" 
#                 or 
# is_software_package_installed "$1" if calling this function from a script
# or another function receiving a parameter.
#
function is_software_package_installed () 
{
        if hash yum 2>/dev/null; then
	        rpm -q "$1" &> /dev/null && return 0 || return 1
        elif hash apt 2>/dev/null; then
	        dpkg -l "$1" &> /dev/null && return 0 || return 1
        elif hash zypper 2>/dev/null; then
                zypper se "$1" &> /dev/null && return 0 || return 1
	else
	        return 3
        fi

}


	

# Function to chek if a package is available in whetever repository, and 
# if there return a "0" and if not return a "1" or a "3" if there is no recognizable 
# package manager found. the function expects the name of the package 
# to be a parameter passed to this fuction. Call this function by: 
# iis_software_package_available "package name" 
#                 or 
# is_software_package_available "$1" if calling this function from a script
# or another function receiving a parameter.
#
function is_software_package_available () 
{
        if hash yum 2>/dev/null; then
	        yum list available "$1" &> /dev/null && return 0 || return 1
        elif hash apt 2>/dev/null; then
                apt -qq list "$1" 2>/dev/null | grep -q "$1" && return 0 || return 1
        elif hash zypper 2>/dev/null; then
                return zypper info "$1" &> /dev/null && return 0 || return 1
	else
	        return 3
        fi

}




# Function to simplify the installation of software by including all display and 
# installation logic for a given software provider. This should be expanded to include flatpack
# snap for example. It should be the same consistent way no matter flavor of Linux. 
# This function uses the "$_INSTCMD" to install software. "$_INSTCMD" is defined separatley and could 
# be an RPM or deb string, or even snap or flatpack. A preference order between package system and
# snap or flatpack use. 
function InstallSoftwareFromRepo ()
{
        # make some decent display terminal fraphics...
        PAD="--------------------------------------------------"
	LINE=$(printf "%s %s" "$@" "$PAD" | cut -c 1-${#PAD})
	# Test if package name is installed, if not then...
        if ! is_software_package_installed "$@"; then
                if is_software_package_available   "$@"; then
                    echo -ne "--- Installing "$LINE" ":" "\ & $_INSTCMD "$@" >>$0.log 2>&1 && printf "%b%-6s%b [ \xE2\x9C\x94 ] $GREEN OK!$ENDCOLOR   \n" ||printf "%b%-6s%b [ ! ] $RED FAILED $ENDCOLOR  \n"
                else
                    echo -ne "--- Installing "$LINE" ":" "\ && printf "%b%-6s%b [ \xE2\x9C\x94 ] $YELLOW NOT AVAILABLE... $ENDCOLOR  \n"
                fi
        else
            echo -ne "--- Installing "$LINE" ":" "\ && printf "%b%-6s%b [ \xE2\x9C\x94 ]  $YELLOW Allready INSTALLED...$ENDCOLOR    \n"
        fi

}





# Function to check that a piece of software is installed and if not install it.
# Works for apt based systems currently. The function will take a parameter that is expected to
# match the softwre command line name or rather the name of the package. This should get
# updated to also check and install from snap and flatpack. 
function check_dependencies ()
{
        #---------------------------------------------------------------
        echo "Checking for script dependencies and install if not there..."
        #---------------------------------------------------------------
            if hash $1 2>/dev/null; then
                echo "I found that $1 is present on this system... thankyou for that! "
            else
                echo "You seem to have no $1... I will try to get it... "
                $_INSTCMD $1
                    if [ $? != 0 ];
                    then
                        echo "That install didn't work out so well."
                        echo "Please manually try to add the software since I couldn't do it."
                        exit
                    fi
                echo "OK Done! Continuing..."
            fi
}


# make prompt colors avaiable to any script that includes this function lbrary.
set_colors
